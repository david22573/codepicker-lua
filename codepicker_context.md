# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	model = nil,
	port = 22573,
	timeout = {
		server_start = 5000, -- ms to wait for server
		request = 30000, -- ms to wait for response
	},
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
	debug = false,
	ui = {
		wrap = true,
		progress_frames = { "‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è" },
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	opts = opts or {}
	-- Validate port
	if opts.port and (opts.port < 1024 or opts.port > 65535) then
		vim.notify("Invalid port number, using default: " .. M.defaults.port, vim.log.levels.WARN)
		opts.port = nil
	end
	-- Validate mappings
	if opts.mappings then
		for k, v in pairs(opts.mappings) do
			if type(v) ~= "string" then
				vim.notify("Invalid mapping for " .. k .. ", using default", vim.log.levels.WARN)
				opts.mappings[k] = nil
			end
		end
	end
	-- Validate timeout values
	if opts.timeout then
		if opts.timeout.server_start and opts.timeout.server_start < 100 then
			vim.notify("server_start timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.server_start = nil
		end
		if opts.timeout.request and opts.timeout.request < 1000 then
			vim.notify("request timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.request = nil
		end
	end
	M.options = vim.tbl_deep_extend("force", M.defaults, opts)
end
return M
```

## File: lua/codepicker/health.lua
```lua
local M = {}
local health = vim.health or require("health")
local start = health.start or health.report_start
local ok = health.ok or health.report_ok
local warn = health.warn or health.report_warn
local error = health.error or health.report_error
local info = health.info or health.report_info
function M.check()
	start("CodePicker")
	-- Check if codepicker binary exists
	local config = require("codepicker.config")
	local cmd = config.options.cmd
	if vim.fn.executable(cmd) == 1 then
		ok("codepicker binary found: " .. cmd)
		-- Try to get version
		local version_output = vim.fn.system(cmd .. " --version 2>&1")
		if vim.v.shell_error == 0 then
			info("Version: " .. vim.trim(version_output))
		end
	else
		error("codepicker binary not found: " .. cmd)
		info("Install from: https://github.com/your-repo/codepicker")
	end
	-- Check if curl is available
	if vim.fn.executable("curl") == 1 then
		ok("curl found")
	else
		error("curl not found - required for HTTP requests")
	end
	-- Check server status
	local server = require("codepicker.server")
	if server.is_running() then
		ok("Server is running")
		info("Uptime: " .. string.format("%.1fs", server.get_uptime()))
		info("URL: " .. server.url("/ask"))
		-- Try health check
		server.wait_ready(function(healthy)
			vim.schedule(function()
				if healthy then
					ok("Server health check passed")
				else
					warn("Server health check failed")
				end
			end)
		end, 2000)
	else
		info("Server is not running (will auto-start on first use)")
	end
	-- Check configuration
	start("Configuration")
	local port = config.options.port
	if port >= 1024 and port <= 65535 then
		ok("Port: " .. port)
	else
		warn("Port out of recommended range: " .. port)
	end
	if config.options.model then
		info("Model: " .. config.options.model)
	else
		info("Model: using server default")
	end
	-- Check keymappings
	start("Keymappings")
	info("Accept: " .. config.options.mappings.accept)
	info("Decline: " .. config.options.mappings.decline)
	-- Check log file
	start("Logging")
	local log = require("codepicker.log")
	local log_path = log.get_log_path()
	if vim.fn.filereadable(log_path) == 1 then
		local size = vim.fn.getfsize(log_path)
		ok("Log file exists: " .. log_path)
		info("Size: " .. size .. " bytes")
		if size > 1024 * 1024 then
			warn("Log file is large (>1MB). Consider running :CodePickerClearLogs")
		end
	else
		info("No log file yet: " .. log_path)
	end
	-- Check dependencies
	start("Dependencies")
	-- Check Neovim version
	local nvim_version = vim.version()
	if nvim_version.minor >= 8 then
		ok("Neovim version: " .. vim.version().major .. "." .. vim.version().minor)
	else
		warn("Neovim 0.8+ recommended, you have: " .. vim.version().major .. "." .. vim.version().minor)
	end
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local server = require("codepicker.server")
local job = require("codepicker.job")
local ui = require("codepicker.ui")
local log = require("codepicker.log")
-- Track active requests for cleanup
local active_requests = {}
-- Setup function to be called by user
function M.setup(opts)
	config.setup(opts)
	-- Auto-start server on first use
	vim.api.nvim_create_autocmd("VimEnter", {
		once = true,
		callback = function()
			if config.options.auto_start ~= false then
				log.debug("Auto-starting server")
			end
		end,
	})
	-- Cleanup on exit
	vim.api.nvim_create_autocmd("VimLeavePre", {
		callback = function()
			log.debug("Cleaning up on exit")
			job.stop_all()
			server.stop()
		end,
	})
	-- Buffer cleanup
	vim.api.nvim_create_autocmd("BufDelete", {
		callback = function(args)
			local buf = args.buf
			if active_requests[buf] then
				job.stop(active_requests[buf])
				active_requests[buf] = nil
			end
		end,
	})
end
-- Ask: Stream AI response to a markdown buffer
function M.ask(query, opts)
	opts = opts or {}
	-- Validate input
	if not query or vim.trim(query) == "" then
		log.error("Query cannot be empty")
		return
	end
	log.info("Ask query: " .. query)
	-- Create UI buffer
	local buf = ui.create_scratch_buf("markdown")
	if not buf then
		log.error("Failed to create buffer")
		return
	end
	local win = ui.open_split(buf)
	if not win then
		log.error("Failed to open split")
		return
	end
	-- Show initial loading message
	local progress_timer = ui.show_progress(buf, "Thinking...")
	-- Start server
	if not server.start() then
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		ui.append_text(buf, "\n‚ùå Failed to start server")
		return
	end
	-- Wait for server to be ready
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			ui.append_text(buf, "\n‚ùå Server failed to start. Try :CodePickerStatus for details.")
			return
		end
		-- Clear loading message
		if vim.api.nvim_buf_is_valid(buf) then
			vim.api.nvim_buf_set_lines(buf, 0, -1, false, { "" })
		end
		-- Prepare request
		local current_file = vim.fn.expand("%:p")
		local payload = vim.fn.json_encode({
			query = query,
			model = config.options.model,
			focus = current_file ~= "" and current_file or nil,
			overwrite = opts.overwrite or false,
		})
		log.debug("Sending request to " .. server.url("/ask"))
		-- Make request
		local request_job = job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			ui.append_text(buf, line .. "\n")
		end, function(code)
			active_requests[buf] = nil
			vim.schedule(function()
				if vim.api.nvim_buf_is_valid(buf) then
					if code == 0 then
						ui.append_text(buf, "\n‚úÖ Done.")
					else
						ui.append_text(buf, "\n‚ùå Request failed with code: " .. code)
					end
				end
			end)
		end)
		if request_job then
			active_requests[buf] = request_job
		else
			ui.append_text(buf, "\n‚ùå Failed to start request")
		end
	end)
end
-- Refactor: Generate code and show diff view
function M.refactor(instruction)
	-- Validate input
	if not instruction or vim.trim(instruction) == "" then
		log.error("Instruction cannot be empty")
		return
	end
	local current_file = vim.fn.expand("%:p")
	if current_file == "" then
		log.error("Save the file first before refactoring")
		return
	end
	log.info("Refactor instruction: " .. instruction)
	local src_buf = vim.api.nvim_get_current_buf()
	local filetype = vim.bo[src_buf].filetype
	-- Create destination buffer
	local dst_buf = ui.create_scratch_buf(filetype)
	if not dst_buf then
		log.error("Failed to create buffer")
		return
	end
	local dst_win = ui.open_split(dst_buf)
	if not dst_win then
		log.error("Failed to open split")
		return
	end
	-- Set buffer name
	vim.api.nvim_buf_set_name(dst_buf, "[CodePicker] Refactored")
	-- Add header
	vim.api.nvim_buf_set_lines(dst_buf, 0, 0, false, {
		"-- AI-generated refactored code",
		"-- " .. config.options.mappings.accept .. " to accept changes",
		"-- " .. config.options.mappings.decline .. " to discard",
		"",
	})
	local progress_timer = ui.show_progress(dst_buf, "Generating code...")
	-- Setup keymaps for accept/decline
	local opts = { noremap = true, silent = true, buffer = dst_buf }
	vim.keymap.set("n", config.options.mappings.accept, function()
		local new_lines = vim.api.nvim_buf_get_lines(dst_buf, 4, -1, false) -- Skip header
		vim.api.nvim_buf_set_lines(src_buf, 0, -1, false, new_lines)
		vim.cmd("diffoff!")
		vim.api.nvim_buf_delete(dst_buf, { force = true })
		vim.cmd("update")
		if #vim.lsp.get_active_clients({ bufnr = src_buf }) > 0 then
			vim.lsp.buf.format({ async = false })
		end
		print("‚úÖ Changes applied")
	end, opts)
	vim.keymap.set("n", config.options.mappings.decline, function()
		vim.cmd("diffoff!")
		vim.api.nvim_buf_delete(dst_buf, { force = true })
		print("‚ùå Changes discarded")
	end, opts)
	-- Start server
	if not server.start() then
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		ui.append_text(dst_buf, "\n‚ùå Failed to start server")
		return
	end
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			ui.append_text(dst_buf, "\n‚ùå Server failed to start")
			return
		end
		-- Clear header for actual code
		vim.api.nvim_buf_set_lines(dst_buf, 4, -1, false, {})
		-- Enhanced prompt
		local prompt = string.format(
			[[You are an expert coding assistant.
Task: Rewrite the following file to satisfy the instruction.
Instruction: %s
CRITICAL REQUIREMENTS:
1. Output the COMPLETE file content - do not stop early or truncate
2. Do NOT use placeholders like "// ... rest of code ..." or "// ... existing code ..."
3. Preserve the existing code structure and style
4. Output ONLY the code - no markdown, no explanations, no code fences
5. Every line of the original file should be represented in your output]],
			instruction
		)
		local payload = vim.fn.json_encode({
			query = prompt,
			model = config.options.model,
			focus = current_file,
		})
		local chunks = {}
		local request_job = job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			table.insert(chunks, line)
		end, function(code)
			active_requests[dst_buf] = nil
			vim.schedule(function()
				if not vim.api.nvim_buf_is_valid(dst_buf) then
					return
				end
				if code ~= 0 then
					ui.append_text(dst_buf, "\n‚ùå Request failed with code: " .. code)
					return
				end
				-- Set buffer content
				vim.api.nvim_buf_set_lines(dst_buf, 4, -1, false, chunks)
				-- Scroll to top
				vim.api.nvim_buf_call(dst_buf, function()
					vim.cmd("normal! gg")
				end)
				-- Enable diff mode
				vim.cmd("windo diffthis")
				print("‚ú® Code generated. Review and accept/decline changes.")
			end)
		end)
		if request_job then
			active_requests[dst_buf] = request_job
		else
			ui.append_text(dst_buf, "\n‚ùå Failed to start request")
		end
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
-- Active jobs registry for cleanup
local active_jobs = {}
-- Lazy load log to avoid circular dependency
local function get_log()
	return require("codepicker.log")
end
function M.run(cmd, on_line, on_exit)
	local buffer = ""
	-- We don't need to rely on the return variable for the callback anymore
	local job_id = vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		stderr_buffered = false,
		on_stdout = function(_, data)
			if not data then
				return
			end
			-- Concatenate all chunks
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					buffer = buffer .. chunk
				end
			end
			-- Process complete lines only
			while buffer:find("\n") do
				local idx = buffer:find("\n")
				local line = buffer:sub(1, idx - 1)
				buffer = buffer:sub(idx + 1)
				-- Filter out markdown code fences and empty lines
				if line ~= "" and not line:match("^```") then
					on_line(line)
				end
			end
		end,
		on_stderr = function(_, data)
			if not data then
				return
			end
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					get_log().error("Job stderr: " .. chunk)
				end
			end
		end,
		-- FIX BELOW: Change "_" to "id" to capture the job ID provided by Neovim
		on_exit = function(id, code)
			-- Flush remaining buffer
			if buffer ~= "" then
				on_line(buffer)
			end
			-- Cleanup: Use 'id' instead of 'job_id'
			active_jobs[id] = nil
			if code ~= 0 then
				get_log().error("Job exited with code: " .. code)
			else
				get_log().debug("Job completed successfully")
			end
			if on_exit then
				on_exit(code)
			end
		end,
	})
	if job_id <= 0 then
		get_log().error("Failed to start job")
		return nil
	end
	active_jobs[job_id] = true
	get_log().debug("Started job: " .. job_id)
	return job_id
end
function M.stop(job_id)
	if job_id and active_jobs[job_id] then
		vim.fn.jobstop(job_id)
		active_jobs[job_id] = nil
		get_log().debug("Stopped job: " .. job_id)
	end
end
function M.stop_all()
	for job_id, _ in pairs(active_jobs) do
		vim.fn.jobstop(job_id)
	end
	active_jobs = {}
	get_log().debug("Stopped all jobs")
end
return M
```

## File: lua/codepicker/log.lua
```lua
local M = {}
local log_file = vim.fn.stdpath("cache") .. "/codepicker.log"
-- Lazy load config to avoid circular dependency
local function get_config()
	return require("codepicker.config")
end
local function write_log(level, msg)
	local f = io.open(log_file, "a")
	if f then
		f:write(os.date("%Y-%m-%d %H:%M:%S") .. " [" .. level .. "] " .. msg .. "\n")
		f:close()
	end
end
function M.debug(msg)
	local config = get_config()
	if config.options.debug then
		write_log("DEBUG", msg)
	end
end
function M.info(msg)
	write_log("INFO", msg)
end
function M.warn(msg)
	write_log("WARN", msg)
	vim.notify(msg, vim.log.levels.WARN)
end
function M.error(msg)
	write_log("ERROR", msg)
	vim.notify(msg, vim.log.levels.ERROR)
end
function M.get_log_path()
	return log_file
end
function M.clear()
	local f = io.open(log_file, "w")
	if f then
		f:close()
	end
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local log = require("codepicker.log")
local job_id = nil
local start_time = nil
function M.start()
	if job_id then
		log.debug("Server already running")
		return true
	end
	-- Check if binary exists
	if vim.fn.executable(config.options.cmd) == 0 then
		log.error("codepicker binary not found: " .. config.options.cmd)
		return false
	end
	local cmd = { config.options.cmd, "serve", "--port", tostring(config.options.port) }
	job_id = vim.fn.jobstart(cmd, {
		detach = false,
		on_stdout = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					log.debug("Server: " .. line)
				end
			end
		end,
		on_stderr = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					log.warn("Server stderr: " .. line)
				end
			end
		end,
		on_exit = function(_, code, _)
			local was_running = job_id ~= nil
			job_id = nil
			start_time = nil
			if was_running then
				if code == 0 or code == 143 then -- 143 = SIGTERM
					log.info("Server stopped gracefully")
				else
					log.error("Server exited with code: " .. code)
				end
			end
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
		log.info("Started codepicker server on port " .. config.options.port)
		return true
	else
		log.error("Failed to start codepicker server")
		job_id = nil
		start_time = nil
		return false
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
		log.info("Stopped codepicker server")
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.get_uptime()
	if not start_time then
		return 0
	end
	return (vim.loop.now() - start_time) / 1000
end
function M.url(path)
	return string.format("http://localhost:%d%s", config.options.port, path)
end
function M.wait_ready(cb, timeout)
	timeout = timeout or config.options.timeout.server_start
	local start = vim.loop.now()
	local attempts = 0
	local max_attempts = math.floor(timeout / 200)
	local done = false
	local function poll()
		if done then
			return
		end
		-- Check if we've timed out
		local elapsed = vim.loop.now() - start
		if elapsed > timeout then
			done = true
			log.error("Server readiness check timed out after " .. elapsed .. "ms")
			cb(false)
			return
		end
		attempts = attempts + 1
		log.debug("Server health check attempt " .. attempts)
		local check_job = vim.fn.jobstart({
			"curl",
			"-s",
			"-o",
			"/dev/null",
			"-w",
			"%{http_code}",
			"--max-time",
			"2",
			M.url("/health"),
		}, {
			on_stdout = function(_, data)
				if done then
					return
				end
				local code = table.concat(data, "")
				log.debug("Health check response: " .. code)
				-- Accept 2xx or 404 (server is up, endpoint may not exist)
				if code:match("^[24]%d%d$") then
					done = true
					log.info("Server is ready")
					cb(true)
				end
			end,
			on_exit = function(_, exit_code)
				if done then
					return
				end
				if exit_code == 0 then
					-- stdout handler will process the response
					return
				end
				-- Connection failed, retry
				if attempts < max_attempts then
					vim.defer_fn(poll, 200)
				else
					done = true
					log.error("Server failed to become ready after " .. attempts .. " attempts")
					cb(false)
				end
			end,
		})
		if check_job <= 0 then
			done = true
			log.error("Failed to start health check job")
			cb(false)
		end
	end
	poll()
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	if not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	vim.bo[buf].buftype = "nofile"
	return buf
end
-- Open a vertical split and focus it
function M.open_split(buf)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.cmd("vsplit")
	local win = vim.api.nvim_get_current_win()
	vim.api.nvim_win_set_buf(win, buf)
	if config.options.ui.wrap then
		vim.wo[win].wrap = true
	end
	return win
end
-- Show progress indicator
function M.show_progress(buf, message)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	local frames = config.options.ui.progress_frames
	local idx = 1
	local timer = vim.loop.new_timer()
	timer:start(
		0,
		100,
		vim.schedule_wrap(function()
			if not vim.api.nvim_buf_is_valid(buf) then
				timer:stop()
				timer:close()
				return
			end
			local line = frames[idx] .. " " .. message
			pcall(vim.api.nvim_buf_set_lines, buf, 0, 1, false, { line })
			idx = (idx % #frames) + 1
		end)
	)
	return timer
end
-- Append text to buffer (handles multiline)
function M.append_text(buf, text)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return false
	end
	vim.schedule(function()
		if not vim.api.nvim_buf_is_valid(buf) then
			return
		end
		local last_line_idx = vim.api.nvim_buf_line_count(buf) - 1
		local last_line = vim.api.nvim_buf_get_lines(buf, last_line_idx, last_line_idx + 1, false)[1]
		local lines = vim.split(text, "\n")
		-- Append to last line
		vim.api.nvim_buf_set_lines(buf, last_line_idx, -1, false, { last_line .. lines[1] })
		-- Add remaining lines
		if #lines > 1 then
			vim.api.nvim_buf_set_lines(buf, -1, -1, false, { unpack(lines, 2) })
		end
		-- Auto-scroll to bottom
		local wins = vim.fn.win_findbuf(buf)
		if #wins > 0 then
			local win = wins[1]
			pcall(vim.api.nvim_win_set_cursor, win, { vim.api.nvim_buf_line_count(buf), 0 })
		end
	end)
	return true
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(generated_buf) then
		return false
	end
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, generated_buf)
	end
	return true
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(original_buf, scratch_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(scratch_buf) then
		return
	end
	local opts = { noremap = true, silent = true, buffer = original_buf }
	local keys = config.options.mappings
	-- Accept (Normal Mode) - use diffget
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		-- Format if LSP is available
		if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
			vim.lsp.buf.format({ async = false })
		end
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
				vim.lsp.buf.format({ async = false })
			end
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff!")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
	-- Print helper message
	vim.schedule(function()
		print(string.format("Review Mode: %s to Accept | %s to Decline", keys.accept or "N/A", keys.decline or "N/A"))
	end)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = true
local codepicker = require("codepicker")
local config = require("codepicker.config")
local server = require("codepicker.server")
local log = require("codepicker.log")
local job = require("codepicker.job")
-- Initialize with defaults
config.setup()
-- Command: :CodePickerAsk "Query"
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide a query.", vim.log.levels.ERROR)
		return
	end
	local options = {
		overwrite = false,
	}
	-- Parse -y flag (overwrite context)
	if args:match("%-y") then
		options.overwrite = true
		args = args:gsub("%-y%s*", "")
		args = vim.trim(args)
	end
	codepicker.ask(args, options)
end, {
	nargs = "+",
	desc = "Ask AI about the codebase",
	complete = function(_, line)
		-- Simple completion suggestions
		local suggestions = {
			"explain this code",
			"how does this work",
			"find bugs in this file",
			"suggest improvements",
			"add documentation",
		}
		return suggestions
	end,
})
-- Command: :CodePickerEdit "Instructions"
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide refactoring instructions.", vim.log.levels.ERROR)
		return
	end
	codepicker.refactor(args)
end, {
	nargs = "+",
	desc = "Refactor current file with AI",
	complete = function(_, line)
		local suggestions = {
			"add error handling",
			"add comments",
			"optimize performance",
			"add type annotations",
			"simplify this code",
			"add unit tests",
		}
		return suggestions
	end,
})
-- Command: :CodePickerStatus - Check daemon status
vim.api.nvim_create_user_command("CodePickerStatus", function()
	if server.is_running() then
		local uptime = server.get_uptime()
		print(string.format("‚úÖ Server running (uptime: %.1fs) at %s", uptime, server.url("/ask")))
		-- Run health check
		server.wait_ready(function(healthy)
			vim.schedule(function()
				if healthy then
					print("‚úÖ Health check passed")
				else
					print("‚ö†Ô∏è  Health check failed - server may not be responding")
				end
			end)
		end, 2000)
	else
		print("‚ùå Server not running. It will start automatically on first use.")
	end
end, {
	desc = "Check codepicker server status",
})
-- Command: :CodePickerRestart - Restart daemon
vim.api.nvim_create_user_command("CodePickerRestart", function()
	print("üîÑ Restarting server...")
	server.stop()
	vim.defer_fn(function()
		if server.start() then
			print("‚úÖ Server restarted successfully")
		else
			print("‚ùå Failed to restart server")
		end
	end, 500)
end, {
	desc = "Restart codepicker server",
})
-- Command: :CodePickerLogs - View logs
vim.api.nvim_create_user_command("CodePickerLogs", function()
	local log_path = log.get_log_path()
	if vim.fn.filereadable(log_path) == 0 then
		print("No logs found at: " .. log_path)
		return
	end
	vim.cmd("split " .. log_path)
	vim.bo.buftype = "nofile"
	vim.bo.bufhidden = "wipe"
	vim.bo.swapfile = false
	-- Auto-scroll to bottom
	vim.cmd("normal! G")
end, {
	desc = "View codepicker logs",
})
-- Command: :CodePickerClearLogs - Clear logs
vim.api.nvim_create_user_command("CodePickerClearLogs", function()
	log.clear()
	print("‚úÖ Logs cleared")
end, {
	desc = "Clear codepicker logs",
})
-- Command: :CodePickerStop - Stop server
vim.api.nvim_create_user_command("CodePickerStop", function()
	if server.is_running() then
		server.stop()
		job.stop_all()
		print("üõë Server stopped")
	else
		print("Server is not running")
	end
end, {
	desc = "Stop codepicker server",
})
```

