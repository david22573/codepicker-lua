# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: codepicker-lua_context.md
```md
# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: codepicker_context.md
```md
# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	-- Default model nil implies using the server's or CLI's default
	model = nil,
	edit = {
		diff_view = true,
	},
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	M.options = vim.tbl_deep_extend("force", M.defaults, opts or {})
	-- Auto-start the daemon when setup is called
	require("codepicker.server").start()
	-- Clean up on exit
	vim.api.nvim_create_autocmd("VimLeavePre", {
		callback = function()
			require("codepicker.server").stop()
		end,
	})
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local Job = require("codepicker.job")
local Server = require("codepicker.server")
-- HELPER: Check if binary exists
local function check_binary()
	if vim.fn.executable(config.options.cmd) == 0 then
		vim.notify("‚ùå codepicker binary not found in PATH: " .. config.options.cmd, vim.log.levels.ERROR)
		return false
	end
	return true
end
-- HELPER: Wait for server to be ready
local function wait_for_server(callback, max_attempts)
	max_attempts = max_attempts or 10
	local attempts = 0
	local function check()
		attempts = attempts + 1
		local url = Server.get_url()
		-- Try a simple health check
		local check_cmd = { "curl", "-s", "-o", "/dev/null", "-w", "%{http_code}", url }
		vim.fn.jobstart(check_cmd, {
			on_exit = function(_, code)
				if code == 0 then
					callback(true)
				elseif attempts < max_attempts then
					vim.defer_fn(check, 200)
				else
					vim.notify("‚ùå Server failed to start after " .. max_attempts .. " attempts", vim.log.levels.ERROR)
					callback(false)
				end
			end,
		})
	end
	check()
end
-- HELPER: Extract code block from Markdown response
local function extract_code(text)
	local code = text:match("```[%w%s]*\n(.*)```")
	if code then
		return code
	end
	return text
end
-- REVIEW MODE KEYMAPS (For Refactor Diff)
local function set_review_keymaps(buf, diff_win, scratch_win)
	local opts = { noremap = true, silent = true, buffer = buf }
	local maps = config.options.mappings
	if maps.accept then
		vim.keymap.set("n", maps.accept, function()
			vim.cmd("normal! do")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Block Accepted & Formatted.")
		end, opts)
		vim.keymap.set("v", maps.accept, function()
			vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
			vim.schedule(function()
				vim.cmd("'<,'>diffget")
				vim.cmd("update")
				vim.lsp.buf.format()
				print("‚úÖ Selection Accepted & Formatted.")
			end)
		end, opts)
	end
	if maps.decline then
		vim.keymap.set({ "n", "v" }, maps.decline, function()
			vim.cmd("diffoff")
			if vim.api.nvim_win_is_valid(scratch_win) then
				vim.api.nvim_win_close(scratch_win, true)
			end
			print("‚ùå Review Cancelled.")
		end, opts)
	end
end
local function setup_diff_view(original_buf, new_buf)
	local ai_wins = vim.fn.win_findbuf(new_buf)
	if #ai_wins > 0 then
		local win = ai_wins[1]
		vim.api.nvim_set_current_win(win)
		vim.cmd("diffthis")
	end
	local orig_wins = vim.fn.win_findbuf(original_buf)
	if #orig_wins > 0 then
		local win = orig_wins[1]
		vim.api.nvim_set_current_win(win)
		vim.cmd("diffthis")
		set_review_keymaps(original_buf, original_buf, ai_wins[1])
		print(
			"REVIEW: "
				.. (config.options.mappings.accept or "N/A")
				.. " to Accept | "
				.. (config.options.mappings.decline or "N/A")
				.. " to Decline"
		)
	end
end
-- ============================================================================
-- CHAT MODE (Ask) - Streams directly to buffer
-- ============================================================================
function M.ask(query, opts)
	if not check_binary() then
		return
	end
	opts = opts or {}
	local overwrite = opts.overwrite or false
	-- Get current file (may be empty)
	local current_file = vim.fn.expand("%:p")
	-- Prepare JSON payload
	local body_data = {
		query = query,
		model = config.options.model or "xiaomi/mimo-v2-flash:free",
		focus = current_file,
		overwrite = overwrite,
	}
	local json_body = vim.fn.json_encode(body_data)
	-- Create Buffer UI
	local buf = vim.api.nvim_create_buf(false, true)
	vim.api.nvim_buf_set_option(buf, "filetype", "markdown")
	vim.api.nvim_buf_set_option(buf, "buftype", "nofile")
	vim.api.nvim_buf_set_option(buf, "bufhidden", "wipe")
	vim.api.nvim_buf_set_option(buf, "swapfile", false)
	vim.cmd("vsplit")
	local win = vim.api.nvim_get_current_win()
	vim.api.nvim_win_set_buf(win, buf)
	vim.api.nvim_win_set_option(win, "wrap", true)
	local function append_text(text)
		vim.schedule(function()
			if not vim.api.nvim_buf_is_valid(buf) then
				return
			end
			local last_line_idx = vim.api.nvim_buf_line_count(buf) - 1
			local last_line = vim.api.nvim_buf_get_lines(buf, last_line_idx, last_line_idx + 1, false)[1]
			local lines = vim.split(text, "\n")
			vim.api.nvim_buf_set_lines(buf, last_line_idx, -1, false, { last_line .. lines[1] })
			if #lines > 1 then
				vim.api.nvim_buf_set_lines(buf, -1, -1, false, { unpack(lines, 2) })
			end
			vim.api.nvim_win_set_cursor(win, { vim.api.nvim_buf_line_count(buf), 0 })
		end)
	end
	local status_msg = "ü§ñ Agent is thinking..."
	if overwrite then
		status_msg = "üî® Rebuilding context & Thinking..."
	end
	vim.api.nvim_buf_set_lines(buf, 0, -1, false, { status_msg, "---" })
	-- Start server and wait for it to be ready
	Server.start()
	wait_for_server(function(ready)
		if not ready then
			append_text("\n‚ùå Server failed to start")
			return
		end
		-- Prepare Curl Command with proper headers
		local url = Server.get_url()
		local cmd = {
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			url,
			"-d",
			json_body,
		}
		local job_id = Job.run(cmd, function(line)
			append_text(line .. "\n")
		end, function()
			vim.schedule(function()
				if vim.api.nvim_buf_is_valid(buf) then
					append_text("\n‚úÖ Done.")
				end
			end)
		end)
		if not job_id then
			append_text("\n‚ùå Failed to start request")
		end
	end)
end
-- ============================================================================
-- EDIT MODE (Refactor) - Accumulates stream, then Diff View
-- ============================================================================
function M.refactor(instruction)
	if not check_binary() then
		return
	end
	local current_buf = vim.api.nvim_get_current_buf()
	local current_file = vim.fn.expand("%:p")
	local file_type = vim.bo.filetype
	if current_file == "" then
		vim.notify("‚ùå Save the file first!", vim.log.levels.ERROR)
		return
	end
	-- Create scratch buffer for result
	local new_buf = vim.api.nvim_create_buf(false, true)
	vim.api.nvim_buf_set_option(new_buf, "filetype", file_type)
	vim.api.nvim_buf_set_option(new_buf, "buftype", "nofile")
	vim.api.nvim_buf_set_option(new_buf, "bufhidden", "wipe")
	vim.api.nvim_buf_set_option(new_buf, "swapfile", false)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, new_buf)
	vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, { "-- ü§ñ Generating code..." })
	local strict_prompt = string.format(
		"Refactor file: %s.\nINSTRUCTION: %s\n"
			.. "CRITICAL: Output ONLY valid code. Do not output markdown text unless inside comments.",
		current_file,
		instruction
	)
	local body_data = {
		query = strict_prompt,
		model = config.options.model or "xiaomi/mimo-v2-flash:free",
		focus = current_file,
		overwrite = false,
	}
	local json_body = vim.fn.json_encode(body_data)
	Server.start()
	wait_for_server(function(ready)
		if not ready then
			vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, { "-- ‚ùå Server failed to start" })
			return
		end
		local url = Server.get_url()
		local cmd = {
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			url,
			"-d",
			json_body,
		}
		local chunks = {}
		Job.run(cmd, function(line)
			table.insert(chunks, line)
		end, function()
			vim.schedule(function()
				local full_output = table.concat(chunks, "\n")
				local clean_code = extract_code(full_output)
				local lines = vim.split(clean_code, "\n")
				if vim.api.nvim_buf_is_valid(new_buf) then
					vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, lines)
					setup_diff_view(current_buf, new_buf)
				end
			end)
		end)
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
-- Stream Parser to handle partial chunks and strip CLI noise
local function create_stream_handler(on_line)
	local buffer = ""
	local ignore_patterns = {
		"^%s*ü§ñ AI Response:",
		"^%s*‚îÄ+$",
		"^%s*Context generated:",
	}
	return function(data)
		if not data then
			return
		end
		for i, chunk in ipairs(data) do
			buffer = buffer .. chunk
			if i < #data then
				local lines = vim.split(buffer, "\n")
				for j = 1, #lines - 1 do
					local line = lines[j]
					local is_noise = false
					for _, pat in ipairs(ignore_patterns) do
						if line:match(pat) then
							is_noise = true
							break
						end
					end
					if not is_noise then
						on_line(line)
					end
				end
				buffer = lines[#lines]
			end
		end
	end
end
function M.run(cmd, on_chunk, on_exit)
	local stdout_handler = create_stream_handler(on_chunk)
	local function stderr_handler(data)
		if not data then
			return
		end
		for _, chunk in ipairs(data) do
			if chunk ~= "" then
				on_chunk("üî¥ ERROR: " .. chunk)
			end
		end
	end
	local job_id = vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		stderr_buffered = false,
		on_stdout = function(_, data)
			stdout_handler(data)
		end,
		on_stderr = function(_, data)
			stderr_handler(data)
		end,
		on_exit = function(_, exit_code)
			if exit_code ~= 0 then
				vim.schedule(function()
					vim.notify("‚ùå Job failed with exit code: " .. exit_code, vim.log.levels.ERROR)
				end)
			end
			if on_exit then
				on_exit(exit_code)
			end
		end,
	})
	if job_id <= 0 then
		vim.notify("‚ùå Failed to start codepicker job", vim.log.levels.ERROR)
		return nil
	end
	return job_id
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local job_id = nil
local port = "22573"
local start_time = nil
function M.start()
	if job_id then
		return
	end
	local bin = config.options.cmd or "codepicker"
	-- Check if binary exists
	if vim.fn.executable(bin) == 0 then
		vim.notify("‚ùå codepicker binary not found: " .. bin, vim.log.levels.ERROR)
		return
	end
	local cmd = { bin, "serve", "--port", port }
	job_id = vim.fn.jobstart(cmd, {
		detach = false,
		on_stdout = function(_, data)
			-- Log server output for debugging
			for _, line in ipairs(data) do
				if line ~= "" then
					vim.schedule(function()
						vim.notify("Server: " .. line, vim.log.levels.DEBUG)
					end)
				end
			end
		end,
		on_stderr = function(_, data)
			-- Log server errors
			for _, line in ipairs(data) do
				if line ~= "" then
					vim.schedule(function()
						vim.notify("Server Error: " .. line, vim.log.levels.WARN)
					end)
				end
			end
		end,
		on_exit = function(_, code, _)
			job_id = nil
			start_time = nil
			if code ~= 0 and code ~= 143 then
				vim.schedule(function()
					vim.notify("‚ö†Ô∏è codepicker daemon exited unexpectedly: " .. code, vim.log.levels.WARN)
				end)
			end
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
		vim.notify("üöÄ Starting codepicker daemon on port " .. port, vim.log.levels.INFO)
	else
		vim.notify("‚ùå Failed to start codepicker daemon", vim.log.levels.ERROR)
		job_id = nil
		start_time = nil
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
		vim.notify("üõë Stopped codepicker daemon", vim.log.levels.INFO)
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.get_uptime()
	if not start_time then
		return 0
	end
	return (vim.loop.now() - start_time) / 1000
end
function M.get_url()
	return "http://localhost:" .. port .. "/ask"
end
-- Health check function
function M.health_check(callback)
	if not M.is_running() then
		callback(false, "Server not running")
		return
	end
	local url = "http://localhost:" .. port .. "/health"
	local cmd = {
		"curl",
		"-s",
		"-o",
		"/dev/null",
		"-w",
		"%{http_code}",
		"--max-time",
		"2",
		url,
	}
	vim.fn.jobstart(cmd, {
		on_stdout = function(_, data)
			local http_code = tonumber(data[1])
			-- Accept 200 or 404 as "server is up"
			if http_code and (http_code == 200 or http_code == 404) then
				callback(true)
			else
				callback(false, "Got HTTP " .. tostring(http_code))
			end
		end,
		on_exit = function(_, exit_code)
			if exit_code ~= 0 then
				callback(false, "Connection failed")
			end
		end,
	})
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Helper: Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	return buf
end
-- Helper: Open a vertical split and focus it
function M.open_split(buf)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	if config.options.ui.wrap then
		vim.wo[0].wrap = true
	end
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	-- Find windows for both buffers
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, orig_win, generated_buf)
	end
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(buf, win, scratch_buf)
	local opts = { noremap = true, silent = true, buffer = buf }
	local keys = config.options.keymaps
	-- Accept (Normal Mode)
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		vim.lsp.buf.format()
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = 1
local codepicker = require("codepicker")
-- Command: :CodePickerAsk "Query"
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	local args = opts.args
	local options = {
		overwrite = false,
		smart = false,
	}
	-- Parse -y (Overwrite)
	if args:match("%-y") then
		options.overwrite = true
		args = args:gsub("%-y%s*", "")
	end
	-- Parse --smart
	if args:match("%-%-smart") or args:match("%-S") then
		options.smart = true
		args = args:gsub("%-%-smart%s*", ""):gsub("%-S%s*", "")
	end
	args = vim.trim(args)
	if args == "" then
		vim.notify("‚ùå Please provide a query.", vim.log.levels.ERROR)
		return
	end
	codepicker.ask(args, options)
end, {
	nargs = "+",
	desc = "Ask AI about the codebase",
})
-- Command: :CodePickerEdit "Instructions"
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide instructions.", vim.log.levels.ERROR)
		return
	end
	codepicker.refactor(args)
end, {
	nargs = "+",
	desc = "Refactor current file with AI",
})
-- Command: :CodePickerStatus - Check daemon status
vim.api.nvim_create_user_command("CodePickerStatus", function()
	local server = require("codepicker.server")
	if server.is_running() then
		local uptime = server.get_uptime()
		print(string.format("‚úÖ Daemon running (uptime: %.1fs) at %s", uptime, server.get_url()))
		-- Run health check
		server.health_check(function(healthy, msg)
			vim.schedule(function()
				if healthy then
					print("‚úÖ Health check passed")
				else
					print("‚ö†Ô∏è Health check failed: " .. (msg or "unknown"))
				end
			end)
		end)
	else
		print("‚ùå Daemon not running")
	end
end, {
	desc = "Check codepicker daemon status",
})
-- Command: :CodePickerRestart - Restart daemon
vim.api.nvim_create_user_command("CodePickerRestart", function()
	local server = require("codepicker.server")
	server.stop()
	vim.defer_fn(function()
		server.start()
	end, 500)
end, {
	desc = "Restart codepicker daemon",
})
```

```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	model = nil,
	port = 22573,
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	M.options = vim.tbl_deep_extend("force", M.defaults, opts or {})
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local server = require("codepicker.server")
local job = require("codepicker.job")
local function open_scratch(ft)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].buftype = "nofile"
	vim.bo[buf].swapfile = false
	vim.bo[buf].filetype = ft
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	return buf
end
function M.ask(query)
	server.start()
	server.wait_ready(function(ok)
		if not ok then
			return
		end
		local buf = open_scratch("markdown")
		vim.api.nvim_buf_set_lines(buf, 0, -1, false, { "ü§ñ Thinking...", "" })
		local payload = vim.fn.json_encode({
			query = query,
			model = config.options.model,
			focus = vim.fn.expand("%:p"),
		})
		job.run({
			"curl",
			"-s",
			"-N",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			vim.schedule(function()
				vim.api.nvim_buf_set_lines(buf, -1, -1, false, { line })
			end)
		end)
	end)
end
function M.refactor(instruction)
	local src = vim.api.nvim_get_current_buf()
	local dst = open_scratch(vim.bo.filetype)
	server.start()
	server.wait_ready(function(ok)
		if not ok then
			return
		end
		local prompt = string.format("Refactor this file. Output ONLY code.\nInstruction: %s", instruction)
		local payload = vim.fn.json_encode({
			query = prompt,
			focus = vim.fn.expand("%:p"),
		})
		local chunks = {}
		job.run({
			"curl",
			"-s",
			"-N",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			table.insert(chunks, line)
		end, function()
			vim.schedule(function()
				vim.api.nvim_buf_set_lines(dst, 0, -1, false, chunks)
				vim.cmd("windo diffthis")
			end)
		end)
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
function M.run(cmd, on_line, on_exit)
	local buffer = ""
	return vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		on_stdout = function(_, data)
			if not data then
				return
			end
			for _, chunk in ipairs(data) do
				buffer = buffer .. chunk .. "\n"
				for line in buffer:gmatch("(.-)\n") do
					on_line(line)
				end
				buffer = ""
			end
		end,
		on_exit = function(_, code)
			if on_exit then
				on_exit(code)
			end
		end,
	})
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local job_id = nil
local start_time = nil
function M.start()
	if job_id then
		return
	end
	local cmd = {
		config.options.cmd,
		"serve",
		"--port",
		tostring(config.options.port),
	}
	job_id = vim.fn.jobstart(cmd, {
		on_exit = function()
			job_id = nil
			start_time = nil
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
	else
		error("Failed to start codepicker daemon")
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.url(path)
	return string.format("http://localhost:%d%s", config.options.port, path)
end
function M.wait_ready(cb)
	local attempts = 0
	local function poll()
		attempts = attempts + 1
		vim.fn.jobstart({
			"curl",
			"-s",
			"-o",
			"/dev/null",
			"-w",
			"%{http_code}",
			M.url("/health"),
		}, {
			on_stdout = function(_, data)
				if data[1] == "200" or data[1] == "404" then
					cb(true)
				elseif attempts < 10 then
					vim.defer_fn(poll, 200)
				else
					cb(false)
				end
			end,
		})
	end
	poll()
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Helper: Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	return buf
end
-- Helper: Open a vertical split and focus it
function M.open_split(buf)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	if config.options.ui.wrap then
		vim.wo[0].wrap = true
	end
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	-- Find windows for both buffers
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, orig_win, generated_buf)
	end
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(buf, win, scratch_buf)
	local opts = { noremap = true, silent = true, buffer = buf }
	local keys = config.options.keymaps
	-- Accept (Normal Mode)
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		vim.lsp.buf.format()
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = true
local codepicker = require("codepicker")
local config = require("codepicker.config")
config.setup()
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	codepicker.ask(opts.args)
end, { nargs = "+" })
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	codepicker.refactor(opts.args)
end, { nargs = "+" })
```

```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	model = nil,
	port = 22573,
	timeout = {
		server_start = 5000, -- ms to wait for server
		request = 30000, -- ms to wait for response
	},
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
	debug = false,
	ui = {
		wrap = true,
		progress_frames = { "‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è" },
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	opts = opts or {}
	-- Validate port
	if opts.port and (opts.port < 1024 or opts.port > 65535) then
		vim.notify("Invalid port number, using default: " .. M.defaults.port, vim.log.levels.WARN)
		opts.port = nil
	end
	-- Validate mappings
	if opts.mappings then
		for k, v in pairs(opts.mappings) do
			if type(v) ~= "string" then
				vim.notify("Invalid mapping for " .. k .. ", using default", vim.log.levels.WARN)
				opts.mappings[k] = nil
			end
		end
	end
	-- Validate timeout values
	if opts.timeout then
		if opts.timeout.server_start and opts.timeout.server_start < 100 then
			vim.notify("server_start timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.server_start = nil
		end
		if opts.timeout.request and opts.timeout.request < 1000 then
			vim.notify("request timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.request = nil
		end
	end
	M.options = vim.tbl_deep_extend("force", M.defaults, opts)
end
return M
```

## File: lua/codepicker/health.lua
```lua
local M = {}
local health = vim.health or require("health")
local start = health.start or health.report_start
local ok = health.ok or health.report_ok
local warn = health.warn or health.report_warn
local error = health.error or health.report_error
local info = health.info or health.report_info
function M.check()
	start("CodePicker")
	-- Check if codepicker binary exists
	local config = require("codepicker.config")
	local cmd = config.options.cmd
	if vim.fn.executable(cmd) == 1 then
		ok("codepicker binary found: " .. cmd)
		-- Try to get version
		local version_output = vim.fn.system(cmd .. " --version 2>&1")
		if vim.v.shell_error == 0 then
			info("Version: " .. vim.trim(version_output))
		end
	else
		error("codepicker binary not found: " .. cmd)
		info("Install from: https://github.com/your-repo/codepicker")
	end
	-- Check if curl is available
	if vim.fn.executable("curl") == 1 then
		ok("curl found")
	else
		error("curl not found - required for HTTP requests")
	end
	-- Check server status
	local server = require("codepicker.server")
	if server.is_running() then
		ok("Server is running")
		info("Uptime: " .. string.format("%.1fs", server.get_uptime()))
		info("URL: " .. server.url("/ask"))
		-- Try health check
		server.wait_ready(function(healthy)
			vim.schedule(function()
				if healthy then
					ok("Server health check passed")
				else
					warn("Server health check failed")
				end
			end)
		end, 2000)
	else
		info("Server is not running (will auto-start on first use)")
	end
	-- Check configuration
	start("Configuration")
	local port = config.options.port
	if port >= 1024 and port <= 65535 then
		ok("Port: " .. port)
	else
		warn("Port out of recommended range: " .. port)
	end
	if config.options.model then
		info("Model: " .. config.options.model)
	else
		info("Model: using server default")
	end
	-- Check keymappings
	start("Keymappings")
	info("Accept: " .. config.options.mappings.accept)
	info("Decline: " .. config.options.mappings.decline)
	-- Check log file
	start("Logging")
	local log = require("codepicker.log")
	local log_path = log.get_log_path()
	if vim.fn.filereadable(log_path) == 1 then
		local size = vim.fn.getfsize(log_path)
		ok("Log file exists: " .. log_path)
		info("Size: " .. size .. " bytes")
		if size > 1024 * 1024 then
			warn("Log file is large (>1MB). Consider running :CodePickerClearLogs")
		end
	else
		info("No log file yet: " .. log_path)
	end
	-- Check dependencies
	start("Dependencies")
	-- Check Neovim version
	local nvim_version = vim.version()
	if nvim_version.minor >= 8 then
		ok("Neovim version: " .. vim.version().major .. "." .. vim.version().minor)
	else
		warn("Neovim 0.8+ recommended, you have: " .. vim.version().major .. "." .. vim.version().minor)
	end
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local server = require("codepicker.server")
local job = require("codepicker.job")
local ui = require("codepicker.ui")
local log = require("codepicker.log")
-- Track active requests for cleanup
local active_requests = {}
-- Setup function to be called by user
function M.setup(opts)
	config.setup(opts)
	-- Auto-start server on first use
	vim.api.nvim_create_autocmd("VimEnter", {
		once = true,
		callback = function()
			if config.options.auto_start ~= false then
				log.debug("Auto-starting server")
			end
		end,
	})
	-- Cleanup on exit
	vim.api.nvim_create_autocmd("VimLeavePre", {
		callback = function()
			log.debug("Cleaning up on exit")
			job.stop_all()
			server.stop()
		end,
	})
	-- Buffer cleanup
	vim.api.nvim_create_autocmd("BufDelete", {
		callback = function(args)
			local buf = args.buf
			if active_requests[buf] then
				job.stop(active_requests[buf])
				active_requests[buf] = nil
			end
		end,
	})
end
-- Ask: Stream AI response to a markdown buffer
function M.ask(query, opts)
	opts = opts or {}
	-- Validate input
	if not query or vim.trim(query) == "" then
		log.error("Query cannot be empty")
		return
	end
	log.info("Ask query: " .. query)
	-- Create UI buffer
	local buf = ui.create_scratch_buf("markdown")
	if not buf then
		log.error("Failed to create buffer")
		return
	end
	local win = ui.open_split(buf)
	if not win then
		log.error("Failed to open split")
		return
	end
	-- Show initial loading message
	local progress_timer = ui.show_progress(buf, "Thinking...")
	-- Start server
	if not server.start() then
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		ui.append_text(buf, "\n‚ùå Failed to start server")
		return
	end
	-- Wait for server to be ready
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			ui.append_text(buf, "\n‚ùå Server failed to start. Try :CodePickerStatus for details.")
			return
		end
		-- Clear loading message
		if vim.api.nvim_buf_is_valid(buf) then
			vim.api.nvim_buf_set_lines(buf, 0, -1, false, { "" })
		end
		-- Prepare request
		local current_file = vim.fn.expand("%:p")
		local payload = vim.fn.json_encode({
			query = query,
			model = config.options.model,
			focus = current_file ~= "" and current_file or nil,
			overwrite = opts.overwrite or false,
		})
		log.debug("Sending request to " .. server.url("/ask"))
		-- Make request
		local request_job = job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			ui.append_text(buf, line .. "\n")
		end, function(code)
			active_requests[buf] = nil
			vim.schedule(function()
				if vim.api.nvim_buf_is_valid(buf) then
					if code == 0 then
						ui.append_text(buf, "\n‚úÖ Done.")
					else
						ui.append_text(buf, "\n‚ùå Request failed with code: " .. code)
					end
				end
			end)
		end)
		if request_job then
			active_requests[buf] = request_job
		else
			ui.append_text(buf, "\n‚ùå Failed to start request")
		end
	end)
end
-- Refactor: Generate code and show diff view
function M.refactor(instruction)
	-- Validate input
	if not instruction or vim.trim(instruction) == "" then
		log.error("Instruction cannot be empty")
		return
	end
	local current_file = vim.fn.expand("%:p")
	if current_file == "" then
		log.error("Save the file first before refactoring")
		return
	end
	log.info("Refactor instruction: " .. instruction)
	local src_buf = vim.api.nvim_get_current_buf()
	local filetype = vim.bo[src_buf].filetype
	-- Create destination buffer
	local dst_buf = ui.create_scratch_buf(filetype)
	if not dst_buf then
		log.error("Failed to create buffer")
		return
	end
	local dst_win = ui.open_split(dst_buf)
	if not dst_win then
		log.error("Failed to open split")
		return
	end
	-- Set buffer name
	vim.api.nvim_buf_set_name(dst_buf, "[CodePicker] Refactored")
	-- Add header
	vim.api.nvim_buf_set_lines(dst_buf, 0, 0, false, {
		"-- AI-generated refactored code",
		"-- " .. config.options.mappings.accept .. " to accept changes",
		"-- " .. config.options.mappings.decline .. " to discard",
		"",
	})
	local progress_timer = ui.show_progress(dst_buf, "Generating code...")
	-- Setup keymaps for accept/decline
	local opts = { noremap = true, silent = true, buffer = dst_buf }
	vim.keymap.set("n", config.options.mappings.accept, function()
		local new_lines = vim.api.nvim_buf_get_lines(dst_buf, 4, -1, false) -- Skip header
		vim.api.nvim_buf_set_lines(src_buf, 0, -1, false, new_lines)
		vim.cmd("diffoff!")
		vim.api.nvim_buf_delete(dst_buf, { force = true })
		vim.cmd("update")
		if #vim.lsp.get_active_clients({ bufnr = src_buf }) > 0 then
			vim.lsp.buf.format({ async = false })
		end
		print("‚úÖ Changes applied")
	end, opts)
	vim.keymap.set("n", config.options.mappings.decline, function()
		vim.cmd("diffoff!")
		vim.api.nvim_buf_delete(dst_buf, { force = true })
		print("‚ùå Changes discarded")
	end, opts)
	-- Start server
	if not server.start() then
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		ui.append_text(dst_buf, "\n‚ùå Failed to start server")
		return
	end
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			ui.append_text(dst_buf, "\n‚ùå Server failed to start")
			return
		end
		-- Clear header for actual code
		vim.api.nvim_buf_set_lines(dst_buf, 4, -1, false, {})
		-- Enhanced prompt
		local prompt = string.format(
			[[You are an expert coding assistant.
Task: Rewrite the following file to satisfy the instruction.
Instruction: %s
CRITICAL REQUIREMENTS:
1. Output the COMPLETE file content - do not stop early or truncate
2. Do NOT use placeholders like "// ... rest of code ..." or "// ... existing code ..."
3. Preserve the existing code structure and style
4. Output ONLY the code - no markdown, no explanations, no code fences
5. Every line of the original file should be represented in your output]],
			instruction
		)
		local payload = vim.fn.json_encode({
			query = prompt,
			model = config.options.model,
			focus = current_file,
		})
		local chunks = {}
		local request_job = job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			table.insert(chunks, line)
		end, function(code)
			active_requests[dst_buf] = nil
			vim.schedule(function()
				if not vim.api.nvim_buf_is_valid(dst_buf) then
					return
				end
				if code ~= 0 then
					ui.append_text(dst_buf, "\n‚ùå Request failed with code: " .. code)
					return
				end
				-- Set buffer content
				vim.api.nvim_buf_set_lines(dst_buf, 4, -1, false, chunks)
				-- Scroll to top
				vim.api.nvim_buf_call(dst_buf, function()
					vim.cmd("normal! gg")
				end)
				-- Enable diff mode
				vim.cmd("windo diffthis")
				print("‚ú® Code generated. Review and accept/decline changes.")
			end)
		end)
		if request_job then
			active_requests[dst_buf] = request_job
		else
			ui.append_text(dst_buf, "\n‚ùå Failed to start request")
		end
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
local log = require("codepicker.log")
-- Active jobs registry for cleanup
local active_jobs = {}
function M.run(cmd, on_line, on_exit)
	local buffer = ""
	local job_id = vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		stderr_buffered = false,
		on_stdout = function(_, data)
			if not data then
				return
			end
			-- Concatenate all chunks
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					buffer = buffer .. chunk
				end
			end
			-- Process complete lines only
			while buffer:find("\n") do
				local idx = buffer:find("\n")
				local line = buffer:sub(1, idx - 1)
				buffer = buffer:sub(idx + 1)
				-- Filter out markdown code fences and empty lines
				if line ~= "" and not line:match("^```") then
					on_line(line)
				end
			end
		end,
		on_stderr = function(_, data)
			if not data then
				return
			end
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					log.error("Job stderr: " .. chunk)
				end
			end
		end,
		on_exit = function(_, code)
			-- Flush remaining buffer (handle cases with no trailing newline)
			if buffer ~= "" then
				on_line(buffer)
			end
			-- Cleanup
			active_jobs[job_id] = nil
			if code ~= 0 then
				log.error("Job exited with code: " .. code)
			else
				log.debug("Job completed successfully")
			end
			if on_exit then
				on_exit(code)
			end
		end,
	})
	if job_id <= 0 then
		log.error("Failed to start job")
		return nil
	end
	active_jobs[job_id] = true
	log.debug("Started job: " .. job_id)
	return job_id
end
function M.stop(job_id)
	if job_id and active_jobs[job_id] then
		vim.fn.jobstop(job_id)
		active_jobs[job_id] = nil
		log.debug("Stopped job: " .. job_id)
	end
end
function M.stop_all()
	for job_id, _ in pairs(active_jobs) do
		vim.fn.jobstop(job_id)
	end
	active_jobs = {}
	log.debug("Stopped all jobs")
end
return M
```

## File: lua/codepicker/log.lua
```lua
local M = {}
local config = require("codepicker.config")
local log_file = vim.fn.stdpath("cache") .. "/codepicker.log"
local function write_log(level, msg)
	local f = io.open(log_file, "a")
	if f then
		f:write(os.date("%Y-%m-%d %H:%M:%S") .. " [" .. level .. "] " .. msg .. "\n")
		f:close()
	end
end
function M.debug(msg)
	if config.options.debug then
		write_log("DEBUG", msg)
	end
end
function M.info(msg)
	write_log("INFO", msg)
end
function M.warn(msg)
	write_log("WARN", msg)
	vim.notify(msg, vim.log.levels.WARN)
end
function M.error(msg)
	write_log("ERROR", msg)
	vim.notify(msg, vim.log.levels.ERROR)
end
function M.get_log_path()
	return log_file
end
function M.clear()
	local f = io.open(log_file, "w")
	if f then
		f:close()
	end
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local log = require("codepicker.log")
local job_id = nil
local start_time = nil
function M.start()
	if job_id then
		log.debug("Server already running")
		return true
	end
	-- Check if binary exists
	if vim.fn.executable(config.options.cmd) == 0 then
		log.error("codepicker binary not found: " .. config.options.cmd)
		return false
	end
	local cmd = { config.options.cmd, "serve", "--port", tostring(config.options.port) }
	job_id = vim.fn.jobstart(cmd, {
		detach = false,
		on_stdout = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					log.debug("Server: " .. line)
				end
			end
		end,
		on_stderr = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					log.warn("Server stderr: " .. line)
				end
			end
		end,
		on_exit = function(_, code, _)
			local was_running = job_id ~= nil
			job_id = nil
			start_time = nil
			if was_running then
				if code == 0 or code == 143 then -- 143 = SIGTERM
					log.info("Server stopped gracefully")
				else
					log.error("Server exited with code: " .. code)
				end
			end
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
		log.info("Started codepicker server on port " .. config.options.port)
		return true
	else
		log.error("Failed to start codepicker server")
		job_id = nil
		start_time = nil
		return false
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
		log.info("Stopped codepicker server")
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.get_uptime()
	if not start_time then
		return 0
	end
	return (vim.loop.now() - start_time) / 1000
end
function M.url(path)
	return string.format("http://localhost:%d%s", config.options.port, path)
end
function M.wait_ready(cb, timeout)
	timeout = timeout or config.options.timeout.server_start
	local start = vim.loop.now()
	local attempts = 0
	local max_attempts = math.floor(timeout / 200)
	local done = false
	local function poll()
		if done then
			return
		end
		-- Check if we've timed out
		local elapsed = vim.loop.now() - start
		if elapsed > timeout then
			done = true
			log.error("Server readiness check timed out after " .. elapsed .. "ms")
			cb(false)
			return
		end
		attempts = attempts + 1
		log.debug("Server health check attempt " .. attempts)
		local check_job = vim.fn.jobstart({
			"curl",
			"-s",
			"-o",
			"/dev/null",
			"-w",
			"%{http_code}",
			"--max-time",
			"2",
			M.url("/health"),
		}, {
			on_stdout = function(_, data)
				if done then
					return
				end
				local code = table.concat(data, "")
				log.debug("Health check response: " .. code)
				-- Accept 2xx or 404 (server is up, endpoint may not exist)
				if code:match("^[24]%d%d$") then
					done = true
					log.info("Server is ready")
					cb(true)
				end
			end,
			on_exit = function(_, exit_code)
				if done then
					return
				end
				if exit_code == 0 then
					-- stdout handler will process the response
					return
				end
				-- Connection failed, retry
				if attempts < max_attempts then
					vim.defer_fn(poll, 200)
				else
					done = true
					log.error("Server failed to become ready after " .. attempts .. " attempts")
					cb(false)
				end
			end,
		})
		if check_job <= 0 then
			done = true
			log.error("Failed to start health check job")
			cb(false)
		end
	end
	poll()
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	if not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	vim.bo[buf].buftype = "nofile"
	return buf
end
-- Open a vertical split and focus it
function M.open_split(buf)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.cmd("vsplit")
	local win = vim.api.nvim_get_current_win()
	vim.api.nvim_win_set_buf(win, buf)
	if config.options.ui.wrap then
		vim.wo[win].wrap = true
	end
	return win
end
-- Show progress indicator
function M.show_progress(buf, message)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	local frames = config.options.ui.progress_frames
	local idx = 1
	local timer = vim.loop.new_timer()
	timer:start(
		0,
		100,
		vim.schedule_wrap(function()
			if not vim.api.nvim_buf_is_valid(buf) then
				timer:stop()
				timer:close()
				return
			end
			local line = frames[idx] .. " " .. message
			pcall(vim.api.nvim_buf_set_lines, buf, 0, 1, false, { line })
			idx = (idx % #frames) + 1
		end)
	)
	return timer
end
-- Append text to buffer (handles multiline)
function M.append_text(buf, text)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return false
	end
	vim.schedule(function()
		if not vim.api.nvim_buf_is_valid(buf) then
			return
		end
		local last_line_idx = vim.api.nvim_buf_line_count(buf) - 1
		local last_line = vim.api.nvim_buf_get_lines(buf, last_line_idx, last_line_idx + 1, false)[1]
		local lines = vim.split(text, "\n")
		-- Append to last line
		vim.api.nvim_buf_set_lines(buf, last_line_idx, -1, false, { last_line .. lines[1] })
		-- Add remaining lines
		if #lines > 1 then
			vim.api.nvim_buf_set_lines(buf, -1, -1, false, { unpack(lines, 2) })
		end
		-- Auto-scroll to bottom
		local wins = vim.fn.win_findbuf(buf)
		if #wins > 0 then
			local win = wins[1]
			pcall(vim.api.nvim_win_set_cursor, win, { vim.api.nvim_buf_line_count(buf), 0 })
		end
	end)
	return true
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(generated_buf) then
		return false
	end
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, generated_buf)
	end
	return true
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(original_buf, scratch_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(scratch_buf) then
		return
	end
	local opts = { noremap = true, silent = true, buffer = original_buf }
	local keys = config.options.mappings
	-- Accept (Normal Mode) - use diffget
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		-- Format if LSP is available
		if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
			vim.lsp.buf.format({ async = false })
		end
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
				vim.lsp.buf.format({ async = false })
			end
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff!")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
	-- Print helper message
	vim.schedule(function()
		print(string.format("Review Mode: %s to Accept | %s to Decline", keys.accept or "N/A", keys.decline or "N/A"))
	end)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = true
local codepicker = require("codepicker")
local config = require("codepicker.config")
local server = require("codepicker.server")
local log = require("codepicker.log")
local job = require("codepicker.job")
-- Initialize with defaults
config.setup()
-- Command: :CodePickerAsk "Query"
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide a query.", vim.log.levels.ERROR)
		return
	end
	local options = {
		overwrite = false,
	}
	-- Parse -y flag (overwrite context)
	if args:match("%-y") then
		options.overwrite = true
		args = args:gsub("%-y%s*", "")
		args = vim.trim(args)
	end
	codepicker.ask(args, options)
end, {
	nargs = "+",
	desc = "Ask AI about the codebase",
	complete = function(_, line)
		-- Simple completion suggestions
		local suggestions = {
			"explain this code",
			"how does this work",
			"find bugs in this file",
			"suggest improvements",
			"add documentation",
		}
		return suggestions
	end,
})
-- Command: :CodePickerEdit "Instructions"
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide refactoring instructions.", vim.log.levels.ERROR)
		return
	end
	codepicker.refactor(args)
end, {
	nargs = "+",
	desc = "Refactor current file with AI",
	complete = function(_, line)
		local suggestions = {
			"add error handling",
			"add comments",
			"optimize performance",
			"add type annotations",
			"simplify this code",
			"add unit tests",
		}
		return suggestions
	end,
})
-- Command: :CodePickerStatus - Check daemon status
vim.api.nvim_create_user_command("CodePickerStatus", function()
	if server.is_running() then
		local uptime = server.get_uptime()
		print(string.format("‚úÖ Server running (uptime: %.1fs) at %s", uptime, server.url("/ask")))
		-- Run health check
		server.wait_ready(function(healthy)
			vim.schedule(function()
				if healthy then
					print("‚úÖ Health check passed")
				else
					print("‚ö†Ô∏è  Health check failed - server may not be responding")
				end
			end)
		end, 2000)
	else
		print("‚ùå Server not running. It will start automatically on first use.")
	end
end, {
	desc = "Check codepicker server status",
})
-- Command: :CodePickerRestart - Restart daemon
vim.api.nvim_create_user_command("CodePickerRestart", function()
	print("üîÑ Restarting server...")
	server.stop()
	vim.defer_fn(function()
		if server.start() then
			print("‚úÖ Server restarted successfully")
		else
			print("‚ùå Failed to restart server")
		end
	end, 500)
end, {
	desc = "Restart codepicker server",
})
-- Command: :CodePickerLogs - View logs
vim.api.nvim_create_user_command("CodePickerLogs", function()
	local log_path = log.get_log_path()
	if vim.fn.filereadable(log_path) == 0 then
		print("No logs found at: " .. log_path)
		return
	end
	vim.cmd("split " .. log_path)
	vim.bo.buftype = "nofile"
	vim.bo.bufhidden = "wipe"
	vim.bo.swapfile = false
	-- Auto-scroll to bottom
	vim.cmd("normal! G")
end, {
	desc = "View codepicker logs",
})
-- Command: :CodePickerClearLogs - Clear logs
vim.api.nvim_create_user_command("CodePickerClearLogs", function()
	log.clear()
	print("‚úÖ Logs cleared")
end, {
	desc = "Clear codepicker logs",
})
-- Command: :CodePickerStop - Stop server
vim.api.nvim_create_user_command("CodePickerStop", function()
	if server.is_running() then
		server.stop()
		job.stop_all()
		print("üõë Server stopped")
	else
		print("Server is not running")
	end
end, {
	desc = "Stop codepicker server",
})
```

