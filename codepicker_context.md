# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: lua\codepicker\config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	model = nil,
	port = 22573,
	timeout = {
		server_start = 60000, -- ms to wait for server
		request = 60000, -- INCREASED: 60s (was 30000) to allow for longer generation times
	},
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
	debug = false,
	ui = {
		wrap = true,
		progress_frames = { "‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è" },
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	opts = opts or {}
	-- Validate port
	if opts.port and (opts.port < 1024 or opts.port > 65535) then
		vim.notify("Invalid port number, using default: " .. M.defaults.port, vim.log.levels.WARN)
		opts.port = nil
	end
	-- Validate mappings
	if opts.mappings then
		for k, v in pairs(opts.mappings) do
			if type(v) ~= "string" then
				vim.notify("Invalid mapping for " .. k .. ", using default", vim.log.levels.WARN)
				opts.mappings[k] = nil
			end
		end
	end
	-- Validate timeout values
	if opts.timeout then
		if opts.timeout.server_start and opts.timeout.server_start < 100 then
			vim.notify("server_start timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.server_start = nil
		end
		if opts.timeout.request and opts.timeout.request < 1000 then
			vim.notify("request timeout too low, using default", vim.log.levels.WARN)
			opts.timeout.request = nil
		end
	end
	M.options = vim.tbl_deep_extend("force", M.defaults, opts)
end
return M
```

## File: lua\codepicker\health.lua
```lua
local M = {}
local health = vim.health or require("health")
local start = health.start or health.report_start
local ok = health.ok or health.report_ok
local warn = health.warn or health.report_warn
local error = health.error or health.report_error
local info = health.info or health.report_info
function M.check()
	start("CodePicker")
	-- Check if codepicker binary exists
	local config = require("codepicker.config")
	local cmd = config.options.cmd
	if vim.fn.executable(cmd) == 1 then
		ok("codepicker binary found: " .. cmd)
		-- Try to get version
		local version_output = vim.fn.system(cmd .. " --version 2>&1")
		if vim.v.shell_error == 0 then
			info("Version: " .. vim.trim(version_output))
		end
	else
		error("codepicker binary not found: " .. cmd)
		info("Install from: https://github.com/your-repo/codepicker")
	end
	-- Check if curl is available
	if vim.fn.executable("curl") == 1 then
		ok("curl found")
	else
		error("curl not found - required for HTTP requests")
	end
	-- Check server status
	local server = require("codepicker.server")
	if server.is_running() then
		ok("Server is running")
		info("Uptime: " .. string.format("%.1fs", server.get_uptime()))
		info("URL: " .. server.url("/ask"))
		-- Try health check
		server.wait_ready(function(healthy)
			vim.schedule(function()
				if healthy then
					ok("Server health check passed")
				else
					warn("Server health check failed")
				end
			end)
		end, 2000)
	else
		info("Server is not running (will auto-start on first use)")
	end
	-- Check configuration
	start("Configuration")
	local port = config.options.port
	if port >= 1024 and port <= 65535 then
		ok("Port: " .. port)
	else
		warn("Port out of recommended range: " .. port)
	end
	if config.options.model then
		info("Model: " .. config.options.model)
	else
		info("Model: using server default")
	end
	-- Check keymappings
	start("Keymappings")
	info("Accept: " .. config.options.mappings.accept)
	info("Decline: " .. config.options.mappings.decline)
	-- Check log file
	start("Logging")
	local log = require("codepicker.log")
	local log_path = log.get_log_path()
	if vim.fn.filereadable(log_path) == 1 then
		local size = vim.fn.getfsize(log_path)
		ok("Log file exists: " .. log_path)
		info("Size: " .. size .. " bytes")
		if size > 1024 * 1024 then
			warn("Log file is large (>1MB). Consider running :CodePickerClearLogs")
		end
	else
		info("No log file yet: " .. log_path)
	end
	-- Check dependencies
	start("Dependencies")
	-- Check Neovim version
	local nvim_version = vim.version()
	if nvim_version.minor >= 8 then
		ok("Neovim version: " .. vim.version().major .. "." .. vim.version().minor)
	else
		warn("Neovim 0.8+ recommended, you have: " .. vim.version().major .. "." .. vim.version().minor)
	end
end
return M
```

## File: lua\codepicker\init.lua
```lua
local M = {}
local config = require("codepicker.config")
local server = require("codepicker.server")
local job = require("codepicker.job")
local ui = require("codepicker.ui")
local log = require("codepicker.log")
-- Track active requests for cleanup
local active_requests = {}
-- Helper: Get text from visual selection
local function get_visual_selection()
	local _, csrow, _, _ = unpack(vim.fn.getpos("'<"))
	local _, cerow, _, _ = unpack(vim.fn.getpos("'>"))
	if csrow > cerow then
		csrow, cerow = cerow, csrow
	end
	local lines = vim.api.nvim_buf_get_lines(0, csrow - 1, cerow, false)
	return table.concat(lines, "\n"), csrow - 1, cerow
end
function M.setup(opts)
	config.setup(opts)
	vim.api.nvim_create_autocmd("VimEnter", {
		once = true,
		callback = function()
			if config.options.auto_start ~= false then
				log.debug("Auto-starting server")
			end
		end,
	})
	vim.api.nvim_create_autocmd("VimLeavePre", {
		callback = function()
			log.debug("Cleaning up on exit")
			job.stop_all()
			server.stop()
		end,
	})
	vim.api.nvim_create_autocmd("BufDelete", {
		callback = function(args)
			local buf = args.buf
			if active_requests[buf] then
				job.stop(active_requests[buf])
				active_requests[buf] = nil
			end
		end,
	})
end
function M.ask(query, opts)
	opts = opts or {}
	if not query or vim.trim(query) == "" then
		log.error("Query cannot be empty")
		return
	end
	local buf = ui.create_scratch_buf("markdown")
	local win = ui.open_split(buf)
	if not buf or not win then
		log.error("Failed to create UI")
		return
	end
	local progress_timer = ui.show_progress(buf, "Thinking...")
	if not server.start() then
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		ui.append_text(buf, "\n‚ùå Failed to start server")
		return
	end
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			ui.append_text(buf, "\n‚ùå Server failed to start")
			return
		end
		vim.api.nvim_buf_set_lines(buf, 0, -1, false, { "" })
		local payload = vim.fn.json_encode({
			query = query,
			model = config.options.model,
			focus = vim.fn.expand("%:p"),
			overwrite = opts.overwrite or false,
		})
		-- FIX: Calculate timeout in seconds
		local timeout_sec = math.ceil(config.options.timeout.request / 1000)
		local request_job = job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"--max-time",
			tostring(timeout_sec), -- FIX: Added timeout flag
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			ui.append_text(buf, line .. "\n")
		end, function(code)
			active_requests[buf] = nil
			if code == 0 then
				ui.append_text(buf, "\n‚úÖ Done.")
			elseif code == 28 then -- curl timeout code
				ui.append_text(buf, "\n‚ùå Request timed out after " .. timeout_sec .. "s")
			else
				ui.append_text(buf, "\n‚ùå Request failed: " .. code)
			end
		end)
		if request_job then
			active_requests[buf] = request_job
		end
	end)
end
function M.refactor(instruction, opts)
	opts = opts or {}
	if not instruction or vim.trim(instruction) == "" then
		log.error("Instruction cannot be empty")
		return
	end
	local src_buf = vim.api.nvim_get_current_buf()
	local filetype = vim.bo[src_buf].filetype
	vim.cmd("update")
	local is_visual = opts.visual
	if is_visual == nil then
		local mode = vim.fn.mode()
		is_visual = mode == "v" or mode == "V" or mode == "\22"
	end
	local code_context, start_line, end_line
	if is_visual then
		code_context, start_line, end_line = get_visual_selection()
	else
		start_line = 0
		end_line = vim.api.nvim_buf_line_count(src_buf)
		code_context = table.concat(vim.api.nvim_buf_get_lines(src_buf, 0, -1, false), "\n")
	end
	local system_prompt
	if is_visual then
		system_prompt = string.format(
			[[You are a coding assistant.
Task: Refactor a selection.
Instruction: %s
```%s
%s
```]],
			instruction,
			filetype,
			code_context
		)
	else
		system_prompt = string.format(
			[[You are a coding assistant.
Task: Rewrite entire file.
Instruction: %s
```%s
%s
```]],
			instruction,
			filetype,
			code_context
		)
	end
	local dst_buf = ui.create_scratch_buf(filetype)
	local dst_win = ui.open_split(dst_buf)
	if not dst_buf or not dst_win then
		log.error("Failed to create refactor UI")
		return
	end
	vim.api.nvim_buf_set_name(dst_buf, "[CodePicker] Refactor")
	local progress_timer = ui.show_progress(dst_buf, "Generating code...")
	server.wait_ready(function(ready)
		if progress_timer then
			progress_timer:stop()
			progress_timer:close()
		end
		if not ready then
			return
		end
		-- FIX: Calculate timeout in seconds
		local timeout_sec = math.ceil(config.options.timeout.request / 1000)
		local payload = vim.fn.json_encode({ query = system_prompt })
		job.run({
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"--max-time",
			tostring(timeout_sec), -- FIX: Added timeout flag
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			if not line:match("^```") then
				vim.api.nvim_buf_set_lines(dst_buf, -1, -1, false, { line })
			end
		end)
	end)
end
return M
```

## File: lua\codepicker\job.lua
```lua
local M = {}
-- Active jobs registry for cleanup
local active_jobs = {}
-- Lazy load log to avoid circular dependency
local function get_log()
	return require("codepicker.log")
end
function M.run(cmd, on_line, on_exit)
	local buffer = ""
	-- We don't need to rely on the return variable for the callback anymore
	local job_id = vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		stderr_buffered = false,
		on_stdout = function(_, data)
			if not data then
				return
			end
			-- Concatenate all chunks
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					buffer = buffer .. chunk
				end
			end
			-- Process complete lines only
			while buffer:find("\n") do
				local idx = buffer:find("\n")
				local line = buffer:sub(1, idx - 1)
				buffer = buffer:sub(idx + 1)
				-- FIX: Pass all lines through.
				-- Logic for filtering fences/empty lines belongs in the consumer (init.lua), not here.
				on_line(line)
			end
		end,
		on_stderr = function(_, data)
			if not data then
				return
			end
			for _, chunk in ipairs(data) do
				if chunk ~= "" then
					get_log().error("Job stderr: " .. chunk)
				end
			end
		end,
		on_exit = function(id, code)
			-- Flush remaining buffer
			if buffer ~= "" then
				on_line(buffer)
			end
			-- Cleanup: Use 'id' instead of 'job_id'
			active_jobs[id] = nil
			if code ~= 0 then
				get_log().error("Job exited with code: " .. code)
			else
				get_log().debug("Job completed successfully")
			end
			if on_exit then
				on_exit(code)
			end
		end,
	})
	if job_id <= 0 then
		get_log().error("Failed to start job")
		return nil
	end
	active_jobs[job_id] = true
	get_log().debug("Started job: " .. job_id)
	return job_id
end
function M.stop(job_id)
	if job_id and active_jobs[job_id] then
		vim.fn.jobstop(job_id)
		active_jobs[job_id] = nil
		get_log().debug("Stopped job: " .. job_id)
	end
end
function M.stop_all()
	for job_id, _ in pairs(active_jobs) do
		vim.fn.jobstop(job_id)
	end
	active_jobs = {}
	get_log().debug("Stopped all jobs")
end
return M
```

## File: lua\codepicker\log.lua
```lua
local M = {}
local log_file = vim.fn.stdpath("cache") .. "/codepicker.log"
-- Lazy load config to avoid circular dependency
local function get_config()
	return require("codepicker.config")
end
local function write_log(level, msg)
	local f = io.open(log_file, "a")
	if f then
		f:write(os.date("%Y-%m-%d %H:%M:%S") .. " [" .. level .. "] " .. msg .. "\n")
		f:close()
	end
end
function M.debug(msg)
	local config = get_config()
	if config.options.debug then
		write_log("DEBUG", msg)
	end
end
function M.info(msg)
	write_log("INFO", msg)
end
function M.warn(msg)
	write_log("WARN", msg)
	vim.notify(msg, vim.log.levels.WARN)
end
function M.error(msg)
	write_log("ERROR", msg)
	vim.notify(msg, vim.log.levels.ERROR)
end
function M.get_log_path()
	return log_file
end
function M.clear()
	local f = io.open(log_file, "w")
	if f then
		f:close()
	end
end
return M
```

## File: lua\codepicker\server.lua
```lua
-- lua/codepicker/server.lua
local M = {}
local config = require("codepicker.config")
local log = require("codepicker.log")
local job_id = nil
local start_time = nil
function M.start()
	if job_id then
		log.debug("Server already running")
		return true
	end
	-- Check if binary exists
	if vim.fn.executable(config.options.cmd) == 0 then
		log.error("codepicker binary not found: " .. config.options.cmd)
		return false
	end
	local cmd = { config.options.cmd, "serve", "--port", tostring(config.options.port) }
	job_id = vim.fn.jobstart(cmd, {
		detach = false,
		on_stdout = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					log.debug("Server: " .. line)
				end
			end
		end,
		on_stderr = function(_, data)
			for _, line in ipairs(data) do
				if line ~= "" then
					-- FIX: Log as INFO/WARN so you can see startup errors even if debug=false
					log.warn("Server stderr: " .. line)
				end
			end
		end,
		on_exit = function(_, code, _)
			local was_running = job_id ~= nil
			job_id = nil
			start_time = nil
			if was_running then
				if code == 0 or code == 143 then -- 143 = SIGTERM
					log.info("Server stopped gracefully")
				else
					log.error("Server exited with code: " .. code)
				end
			end
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
		log.info("Started codepicker server on port " .. config.options.port)
		return true
	else
		log.error("Failed to start codepicker server")
		job_id = nil
		start_time = nil
		return false
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
		log.info("Stopped codepicker server")
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.get_uptime()
	if not start_time then
		return 0
	end
	return (vim.loop.now() - start_time) / 1000
end
function M.url(path)
	-- FIX: Use 127.0.0.1 instead of localhost to avoid IPv6 resolution timeouts
	return string.format("http://127.0.0.1:%d%s", config.options.port, path)
end
function M.wait_ready(cb, timeout)
	timeout = timeout or config.options.timeout.server_start
	local start = vim.loop.now()
	local attempts = 0
	local max_attempts = math.floor(timeout / 200)
	local done = false
	local function poll()
		if done then
			return
		end
		-- Check if we've timed out
		local elapsed = vim.loop.now() - start
		if elapsed > timeout then
			done = true
			log.error("Server readiness check timed out after " .. elapsed .. "ms")
			cb(false)
			return
		end
		attempts = attempts + 1
		log.debug("Server health check attempt " .. attempts)
		local check_job = vim.fn.jobstart({
			"curl",
			"-s",
			"-o",
			"/dev/null",
			"-w",
			"%{http_code}",
			"--max-time",
			"2",
			M.url("/health"),
		}, {
			on_stdout = function(_, data)
				if done then
					return
				end
				local code = table.concat(data, "")
				log.debug("Health check response: " .. code)
				-- Accept 2xx or 404 (server is up, endpoint may not exist)
				if code:match("^[24]%d%d$") then
					done = true
					log.info("Server is ready")
					cb(true)
				end
			end,
			on_exit = function(_, exit_code)
				if done then
					return
				end
				if exit_code == 0 then
					-- stdout handler will process the response
					return
				end
				-- Connection failed, retry
				if attempts < max_attempts then
					vim.defer_fn(poll, 200)
				else
					done = true
					log.error("Server failed to become ready after " .. attempts .. " attempts")
					cb(false)
				end
			end,
		})
		if check_job <= 0 then
			done = true
			log.error("Failed to start health check job")
			cb(false)
		end
	end
	poll()
end
return M
```

## File: lua\codepicker\ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	if not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	vim.bo[buf].buftype = "nofile"
	return buf
end
-- Open a vertical split and focus it
function M.open_split(buf)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	vim.cmd("vsplit")
	local win = vim.api.nvim_get_current_win()
	vim.api.nvim_win_set_buf(win, buf)
	if config.options.ui.wrap then
		vim.wo[win].wrap = true
	end
	return win
end
-- Show progress indicator
function M.show_progress(buf, message)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return nil
	end
	local frames = config.options.ui.progress_frames
	local idx = 1
	local timer = vim.loop.new_timer()
	timer:start(
		0,
		100,
		vim.schedule_wrap(function()
			if not vim.api.nvim_buf_is_valid(buf) then
				timer:stop()
				timer:close()
				return
			end
			local line = frames[idx] .. " " .. message
			pcall(vim.api.nvim_buf_set_lines, buf, 0, 1, false, { line })
			idx = (idx % #frames) + 1
		end)
	)
	return timer
end
-- Append text to buffer (handles multiline)
function M.append_text(buf, text)
	if not buf or not vim.api.nvim_buf_is_valid(buf) then
		return false
	end
	vim.schedule(function()
		if not vim.api.nvim_buf_is_valid(buf) then
			return
		end
		local last_line_idx = vim.api.nvim_buf_line_count(buf) - 1
		local last_line = vim.api.nvim_buf_get_lines(buf, last_line_idx, last_line_idx + 1, false)[1]
		local lines = vim.split(text, "\n")
		-- Append to last line
		vim.api.nvim_buf_set_lines(buf, last_line_idx, -1, false, { last_line .. lines[1] })
		-- Add remaining lines
		if #lines > 1 then
			vim.api.nvim_buf_set_lines(buf, -1, -1, false, { unpack(lines, 2) })
		end
		-- Auto-scroll to bottom
		local wins = vim.fn.win_findbuf(buf)
		if #wins > 0 then
			local win = wins[1]
			pcall(vim.api.nvim_win_set_cursor, win, { vim.api.nvim_buf_line_count(buf), 0 })
		end
	end)
	return true
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(generated_buf) then
		return false
	end
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, generated_buf)
	end
	return true
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(original_buf, scratch_buf)
	if not vim.api.nvim_buf_is_valid(original_buf) or not vim.api.nvim_buf_is_valid(scratch_buf) then
		return
	end
	local opts = { noremap = true, silent = true, buffer = original_buf }
	local keys = config.options.mappings
	-- Accept (Normal Mode) - use diffget
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		-- Format if LSP is available
		if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
			vim.lsp.buf.format({ async = false })
		end
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			if #vim.lsp.get_active_clients({ bufnr = 0 }) > 0 then
				vim.lsp.buf.format({ async = false })
			end
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff!")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
	-- Print helper message
	vim.schedule(function()
		print(string.format("Review Mode: %s to Accept | %s to Decline", keys.accept or "N/A", keys.decline or "N/A"))
	end)
end
return M
```

## File: plugin\codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = true
local codepicker = require("codepicker")
local config = require("codepicker.config")
local server = require("codepicker.server")
local log = require("codepicker.log")
local job = require("codepicker.job")
config.setup()
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide a query", vim.log.levels.ERROR)
		return
	end
	codepicker.ask(args, {})
end, { nargs = "+" })
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide instructions", vim.log.levels.ERROR)
		return
	end
	codepicker.refactor(args, { visual = opts.range > 0 })
end, { nargs = "+", range = true })
vim.api.nvim_create_user_command("CodePickerStatus", function()
	if server.is_running() then
		print("‚úÖ Server running")
	else
		print("‚ùå Server not running")
	end
end, {})
vim.api.nvim_create_user_command("CodePickerStop", function()
	server.stop()
	job.stop_all()
	print("üõë Server stopped")
end, {})
```

