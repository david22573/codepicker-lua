# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: codepicker_context.md
```md
# Codebase Context Dump
Generated by codepicker

## File: .codepicker.yml
```yml
# .codepicker.yml
# Generated by codepicker init

src: .
output: codepicker_context.md
minify: true
tokens: false

# File extensions to include (add more as needed)
include:
  - .go
  - .ts
  - .js

# Directories to exclude
exclude:
  - .git
  - node_modules
  - vendor
  - codepicker_out

# AI integration settings
ai:
  model: xiaomi/mimo-v2-flash:free
  temperature: 0.7
```

## File: README.md
```md
# codepicker-lua
Neovim codepicker extension for agentic IDE experience 
```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	-- Default model nil implies using the server's or CLI's default
	model = nil,
	edit = {
		diff_view = true,
	},
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	M.options = vim.tbl_deep_extend("force", M.defaults, opts or {})
	-- Auto-start the daemon when setup is called
	require("codepicker.server").start()
	-- Clean up on exit
	vim.api.nvim_create_autocmd("VimLeavePre", {
		callback = function()
			require("codepicker.server").stop()
		end,
	})
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local Job = require("codepicker.job")
local Server = require("codepicker.server")
-- HELPER: Check if binary exists
local function check_binary()
	if vim.fn.executable(config.options.cmd) == 0 then
		vim.notify("‚ùå codepicker binary not found in PATH: " .. config.options.cmd, vim.log.levels.ERROR)
		return false
	end
	return true
end
-- HELPER: Wait for server to be ready
local function wait_for_server(callback, max_attempts)
	max_attempts = max_attempts or 10
	local attempts = 0
	local function check()
		attempts = attempts + 1
		local url = Server.get_url()
		-- Try a simple health check
		local check_cmd = { "curl", "-s", "-o", "/dev/null", "-w", "%{http_code}", url }
		vim.fn.jobstart(check_cmd, {
			on_exit = function(_, code)
				if code == 0 then
					callback(true)
				elseif attempts < max_attempts then
					vim.defer_fn(check, 200)
				else
					vim.notify("‚ùå Server failed to start after " .. max_attempts .. " attempts", vim.log.levels.ERROR)
					callback(false)
				end
			end,
		})
	end
	check()
end
-- HELPER: Extract code block from Markdown response
local function extract_code(text)
	local code = text:match("```[%w%s]*\n(.*)```")
	if code then
		return code
	end
	return text
end
-- REVIEW MODE KEYMAPS (For Refactor Diff)
local function set_review_keymaps(buf, diff_win, scratch_win)
	local opts = { noremap = true, silent = true, buffer = buf }
	local maps = config.options.mappings
	if maps.accept then
		vim.keymap.set("n", maps.accept, function()
			vim.cmd("normal! do")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Block Accepted & Formatted.")
		end, opts)
		vim.keymap.set("v", maps.accept, function()
			vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
			vim.schedule(function()
				vim.cmd("'<,'>diffget")
				vim.cmd("update")
				vim.lsp.buf.format()
				print("‚úÖ Selection Accepted & Formatted.")
			end)
		end, opts)
	end
	if maps.decline then
		vim.keymap.set({ "n", "v" }, maps.decline, function()
			vim.cmd("diffoff")
			if vim.api.nvim_win_is_valid(scratch_win) then
				vim.api.nvim_win_close(scratch_win, true)
			end
			print("‚ùå Review Cancelled.")
		end, opts)
	end
end
local function setup_diff_view(original_buf, new_buf)
	local ai_wins = vim.fn.win_findbuf(new_buf)
	if #ai_wins > 0 then
		local win = ai_wins[1]
		vim.api.nvim_set_current_win(win)
		vim.cmd("diffthis")
	end
	local orig_wins = vim.fn.win_findbuf(original_buf)
	if #orig_wins > 0 then
		local win = orig_wins[1]
		vim.api.nvim_set_current_win(win)
		vim.cmd("diffthis")
		set_review_keymaps(original_buf, original_buf, ai_wins[1])
		print(
			"REVIEW: "
				.. (config.options.mappings.accept or "N/A")
				.. " to Accept | "
				.. (config.options.mappings.decline or "N/A")
				.. " to Decline"
		)
	end
end
-- ============================================================================
-- CHAT MODE (Ask) - Streams directly to buffer
-- ============================================================================
function M.ask(query, opts)
	if not check_binary() then
		return
	end
	opts = opts or {}
	local overwrite = opts.overwrite or false
	-- Get current file (may be empty)
	local current_file = vim.fn.expand("%:p")
	-- Prepare JSON payload
	local body_data = {
		query = query,
		model = config.options.model or "xiaomi/mimo-v2-flash:free",
		focus = current_file,
		overwrite = overwrite,
	}
	local json_body = vim.fn.json_encode(body_data)
	-- Create Buffer UI
	local buf = vim.api.nvim_create_buf(false, true)
	vim.api.nvim_buf_set_option(buf, "filetype", "markdown")
	vim.api.nvim_buf_set_option(buf, "buftype", "nofile")
	vim.api.nvim_buf_set_option(buf, "bufhidden", "wipe")
	vim.api.nvim_buf_set_option(buf, "swapfile", false)
	vim.cmd("vsplit")
	local win = vim.api.nvim_get_current_win()
	vim.api.nvim_win_set_buf(win, buf)
	vim.api.nvim_win_set_option(win, "wrap", true)
	local function append_text(text)
		vim.schedule(function()
			if not vim.api.nvim_buf_is_valid(buf) then
				return
			end
			local last_line_idx = vim.api.nvim_buf_line_count(buf) - 1
			local last_line = vim.api.nvim_buf_get_lines(buf, last_line_idx, last_line_idx + 1, false)[1]
			local lines = vim.split(text, "\n")
			vim.api.nvim_buf_set_lines(buf, last_line_idx, -1, false, { last_line .. lines[1] })
			if #lines > 1 then
				vim.api.nvim_buf_set_lines(buf, -1, -1, false, { unpack(lines, 2) })
			end
			vim.api.nvim_win_set_cursor(win, { vim.api.nvim_buf_line_count(buf), 0 })
		end)
	end
	local status_msg = "ü§ñ Agent is thinking..."
	if overwrite then
		status_msg = "üî® Rebuilding context & Thinking..."
	end
	vim.api.nvim_buf_set_lines(buf, 0, -1, false, { status_msg, "---" })
	-- Start server and wait for it to be ready
	Server.start()
	wait_for_server(function(ready)
		if not ready then
			append_text("\n‚ùå Server failed to start")
			return
		end
		-- Prepare Curl Command with proper headers
		local url = Server.get_url()
		local cmd = {
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			url,
			"-d",
			json_body,
		}
		local job_id = Job.run(cmd, function(line)
			append_text(line .. "\n")
		end, function()
			vim.schedule(function()
				if vim.api.nvim_buf_is_valid(buf) then
					append_text("\n‚úÖ Done.")
				end
			end)
		end)
		if not job_id then
			append_text("\n‚ùå Failed to start request")
		end
	end)
end
-- ============================================================================
-- EDIT MODE (Refactor) - Accumulates stream, then Diff View
-- ============================================================================
function M.refactor(instruction)
	if not check_binary() then
		return
	end
	local current_buf = vim.api.nvim_get_current_buf()
	local current_file = vim.fn.expand("%:p")
	local file_type = vim.bo.filetype
	if current_file == "" then
		vim.notify("‚ùå Save the file first!", vim.log.levels.ERROR)
		return
	end
	-- Create scratch buffer for result
	local new_buf = vim.api.nvim_create_buf(false, true)
	vim.api.nvim_buf_set_option(new_buf, "filetype", file_type)
	vim.api.nvim_buf_set_option(new_buf, "buftype", "nofile")
	vim.api.nvim_buf_set_option(new_buf, "bufhidden", "wipe")
	vim.api.nvim_buf_set_option(new_buf, "swapfile", false)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, new_buf)
	vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, { "-- ü§ñ Generating code..." })
	local strict_prompt = string.format(
		"Refactor file: %s.\nINSTRUCTION: %s\n"
			.. "CRITICAL: Output ONLY valid code. Do not output markdown text unless inside comments.",
		current_file,
		instruction
	)
	local body_data = {
		query = strict_prompt,
		model = config.options.model or "xiaomi/mimo-v2-flash:free",
		focus = current_file,
		overwrite = false,
	}
	local json_body = vim.fn.json_encode(body_data)
	Server.start()
	wait_for_server(function(ready)
		if not ready then
			vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, { "-- ‚ùå Server failed to start" })
			return
		end
		local url = Server.get_url()
		local cmd = {
			"curl",
			"-s",
			"-N",
			"--no-buffer",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			url,
			"-d",
			json_body,
		}
		local chunks = {}
		Job.run(cmd, function(line)
			table.insert(chunks, line)
		end, function()
			vim.schedule(function()
				local full_output = table.concat(chunks, "\n")
				local clean_code = extract_code(full_output)
				local lines = vim.split(clean_code, "\n")
				if vim.api.nvim_buf_is_valid(new_buf) then
					vim.api.nvim_buf_set_lines(new_buf, 0, -1, false, lines)
					setup_diff_view(current_buf, new_buf)
				end
			end)
		end)
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
-- Stream Parser to handle partial chunks and strip CLI noise
local function create_stream_handler(on_line)
	local buffer = ""
	local ignore_patterns = {
		"^%s*ü§ñ AI Response:",
		"^%s*‚îÄ+$",
		"^%s*Context generated:",
	}
	return function(data)
		if not data then
			return
		end
		for i, chunk in ipairs(data) do
			buffer = buffer .. chunk
			if i < #data then
				local lines = vim.split(buffer, "\n")
				for j = 1, #lines - 1 do
					local line = lines[j]
					local is_noise = false
					for _, pat in ipairs(ignore_patterns) do
						if line:match(pat) then
							is_noise = true
							break
						end
					end
					if not is_noise then
						on_line(line)
					end
				end
				buffer = lines[#lines]
			end
		end
	end
end
function M.run(cmd, on_chunk, on_exit)
	local stdout_handler = create_stream_handler(on_chunk)
	local function stderr_handler(data)
		if not data then
			return
		end
		for _, chunk in ipairs(data) do
			if chunk ~= "" then
				on_chunk("üî¥ ERROR: " .. chunk)
			end
		end
	end
	local job_id = vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		stderr_buffered = false,
		on_stdout = function(_, data)
			stdout_handler(data)
		end,
		on_stderr = function(_, data)
			stderr_handler(data)
		end,
		on_exit = function(_, exit_code)
			if exit_code ~= 0 then
				vim.schedule(function()
					vim.notify("‚ùå Job failed with exit code: " .. exit_code, vim.log.levels.ERROR)
				end)
			end
			if on_exit then
				on_exit(exit_code)
			end
		end,
	})
	if job_id <= 0 then
		vim.notify("‚ùå Failed to start codepicker job", vim.log.levels.ERROR)
		return nil
	end
	return job_id
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local job_id = nil
local port = "22573"
local start_time = nil
function M.start()
	if job_id then
		return
	end
	local bin = config.options.cmd or "codepicker"
	-- Check if binary exists
	if vim.fn.executable(bin) == 0 then
		vim.notify("‚ùå codepicker binary not found: " .. bin, vim.log.levels.ERROR)
		return
	end
	local cmd = { bin, "serve", "--port", port }
	job_id = vim.fn.jobstart(cmd, {
		detach = false,
		on_stdout = function(_, data)
			-- Log server output for debugging
			for _, line in ipairs(data) do
				if line ~= "" then
					vim.schedule(function()
						vim.notify("Server: " .. line, vim.log.levels.DEBUG)
					end)
				end
			end
		end,
		on_stderr = function(_, data)
			-- Log server errors
			for _, line in ipairs(data) do
				if line ~= "" then
					vim.schedule(function()
						vim.notify("Server Error: " .. line, vim.log.levels.WARN)
					end)
				end
			end
		end,
		on_exit = function(_, code, _)
			job_id = nil
			start_time = nil
			if code ~= 0 and code ~= 143 then
				vim.schedule(function()
					vim.notify("‚ö†Ô∏è codepicker daemon exited unexpectedly: " .. code, vim.log.levels.WARN)
				end)
			end
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
		vim.notify("üöÄ Starting codepicker daemon on port " .. port, vim.log.levels.INFO)
	else
		vim.notify("‚ùå Failed to start codepicker daemon", vim.log.levels.ERROR)
		job_id = nil
		start_time = nil
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
		vim.notify("üõë Stopped codepicker daemon", vim.log.levels.INFO)
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.get_uptime()
	if not start_time then
		return 0
	end
	return (vim.loop.now() - start_time) / 1000
end
function M.get_url()
	return "http://localhost:" .. port .. "/ask"
end
-- Health check function
function M.health_check(callback)
	if not M.is_running() then
		callback(false, "Server not running")
		return
	end
	local url = "http://localhost:" .. port .. "/health"
	local cmd = {
		"curl",
		"-s",
		"-o",
		"/dev/null",
		"-w",
		"%{http_code}",
		"--max-time",
		"2",
		url,
	}
	vim.fn.jobstart(cmd, {
		on_stdout = function(_, data)
			local http_code = tonumber(data[1])
			-- Accept 200 or 404 as "server is up"
			if http_code and (http_code == 200 or http_code == 404) then
				callback(true)
			else
				callback(false, "Got HTTP " .. tostring(http_code))
			end
		end,
		on_exit = function(_, exit_code)
			if exit_code ~= 0 then
				callback(false, "Connection failed")
			end
		end,
	})
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Helper: Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	return buf
end
-- Helper: Open a vertical split and focus it
function M.open_split(buf)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	if config.options.ui.wrap then
		vim.wo[0].wrap = true
	end
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	-- Find windows for both buffers
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, orig_win, generated_buf)
	end
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(buf, win, scratch_buf)
	local opts = { noremap = true, silent = true, buffer = buf }
	local keys = config.options.keymaps
	-- Accept (Normal Mode)
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		vim.lsp.buf.format()
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = 1
local codepicker = require("codepicker")
-- Command: :CodePickerAsk "Query"
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	local args = opts.args
	local options = {
		overwrite = false,
		smart = false,
	}
	-- Parse -y (Overwrite)
	if args:match("%-y") then
		options.overwrite = true
		args = args:gsub("%-y%s*", "")
	end
	-- Parse --smart
	if args:match("%-%-smart") or args:match("%-S") then
		options.smart = true
		args = args:gsub("%-%-smart%s*", ""):gsub("%-S%s*", "")
	end
	args = vim.trim(args)
	if args == "" then
		vim.notify("‚ùå Please provide a query.", vim.log.levels.ERROR)
		return
	end
	codepicker.ask(args, options)
end, {
	nargs = "+",
	desc = "Ask AI about the codebase",
})
-- Command: :CodePickerEdit "Instructions"
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	local args = vim.trim(opts.args)
	if args == "" then
		vim.notify("‚ùå Please provide instructions.", vim.log.levels.ERROR)
		return
	end
	codepicker.refactor(args)
end, {
	nargs = "+",
	desc = "Refactor current file with AI",
})
-- Command: :CodePickerStatus - Check daemon status
vim.api.nvim_create_user_command("CodePickerStatus", function()
	local server = require("codepicker.server")
	if server.is_running() then
		local uptime = server.get_uptime()
		print(string.format("‚úÖ Daemon running (uptime: %.1fs) at %s", uptime, server.get_url()))
		-- Run health check
		server.health_check(function(healthy, msg)
			vim.schedule(function()
				if healthy then
					print("‚úÖ Health check passed")
				else
					print("‚ö†Ô∏è Health check failed: " .. (msg or "unknown"))
				end
			end)
		end)
	else
		print("‚ùå Daemon not running")
	end
end, {
	desc = "Check codepicker daemon status",
})
-- Command: :CodePickerRestart - Restart daemon
vim.api.nvim_create_user_command("CodePickerRestart", function()
	local server = require("codepicker.server")
	server.stop()
	vim.defer_fn(function()
		server.start()
	end, 500)
end, {
	desc = "Restart codepicker daemon",
})
```

```

## File: lua/codepicker/config.lua
```lua
local M = {}
M.defaults = {
	cmd = "codepicker",
	model = nil,
	port = 22573,
	mappings = {
		accept = "<C-CR>",
		decline = "<C-BS>",
	},
}
M.options = vim.deepcopy(M.defaults)
function M.setup(opts)
	M.options = vim.tbl_deep_extend("force", M.defaults, opts or {})
end
return M
```

## File: lua/codepicker/init.lua
```lua
local M = {}
local config = require("codepicker.config")
local server = require("codepicker.server")
local job = require("codepicker.job")
local function open_scratch(ft)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].buftype = "nofile"
	vim.bo[buf].swapfile = false
	vim.bo[buf].filetype = ft
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	return buf
end
function M.ask(query)
	server.start()
	server.wait_ready(function(ok)
		if not ok then
			return
		end
		local buf = open_scratch("markdown")
		vim.api.nvim_buf_set_lines(buf, 0, -1, false, { "ü§ñ Thinking...", "" })
		local payload = vim.fn.json_encode({
			query = query,
			model = config.options.model,
			focus = vim.fn.expand("%:p"),
		})
		job.run({
			"curl",
			"-s",
			"-N",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			vim.schedule(function()
				vim.api.nvim_buf_set_lines(buf, -1, -1, false, { line })
			end)
		end)
	end)
end
function M.refactor(instruction)
	local src = vim.api.nvim_get_current_buf()
	local dst = open_scratch(vim.bo.filetype)
	server.start()
	server.wait_ready(function(ok)
		if not ok then
			return
		end
		local prompt = string.format("Refactor this file. Output ONLY code.\nInstruction: %s", instruction)
		local payload = vim.fn.json_encode({
			query = prompt,
			focus = vim.fn.expand("%:p"),
		})
		local chunks = {}
		job.run({
			"curl",
			"-s",
			"-N",
			"-H",
			"Content-Type: application/json",
			"-X",
			"POST",
			server.url("/ask"),
			"-d",
			payload,
		}, function(line)
			table.insert(chunks, line)
		end, function()
			vim.schedule(function()
				vim.api.nvim_buf_set_lines(dst, 0, -1, false, chunks)
				vim.cmd("windo diffthis")
			end)
		end)
	end)
end
return M
```

## File: lua/codepicker/job.lua
```lua
local M = {}
function M.run(cmd, on_line, on_exit)
	local buffer = ""
	return vim.fn.jobstart(cmd, {
		stdout_buffered = false,
		on_stdout = function(_, data)
			if not data then
				return
			end
			for _, chunk in ipairs(data) do
				buffer = buffer .. chunk .. "\n"
				for line in buffer:gmatch("(.-)\n") do
					on_line(line)
				end
				buffer = ""
			end
		end,
		on_exit = function(_, code)
			if on_exit then
				on_exit(code)
			end
		end,
	})
end
return M
```

## File: lua/codepicker/server.lua
```lua
local M = {}
local config = require("codepicker.config")
local job_id = nil
local start_time = nil
function M.start()
	if job_id then
		return
	end
	local cmd = {
		config.options.cmd,
		"serve",
		"--port",
		tostring(config.options.port),
	}
	job_id = vim.fn.jobstart(cmd, {
		on_exit = function()
			job_id = nil
			start_time = nil
		end,
	})
	if job_id > 0 then
		start_time = vim.loop.now()
	else
		error("Failed to start codepicker daemon")
	end
end
function M.stop()
	if job_id then
		vim.fn.jobstop(job_id)
		job_id = nil
		start_time = nil
	end
end
function M.is_running()
	return job_id ~= nil
end
function M.url(path)
	return string.format("http://localhost:%d%s", config.options.port, path)
end
function M.wait_ready(cb)
	local attempts = 0
	local function poll()
		attempts = attempts + 1
		vim.fn.jobstart({
			"curl",
			"-s",
			"-o",
			"/dev/null",
			"-w",
			"%{http_code}",
			M.url("/health"),
		}, {
			on_stdout = function(_, data)
				if data[1] == "200" or data[1] == "404" then
					cb(true)
				elseif attempts < 10 then
					vim.defer_fn(poll, 200)
				else
					cb(false)
				end
			end,
		})
	end
	poll()
end
return M
```

## File: lua/codepicker/ui.lua
```lua
local M = {}
local config = require("codepicker.config")
-- Helper: Create a scratch buffer with specific options
function M.create_scratch_buf(filetype)
	local buf = vim.api.nvim_create_buf(false, true)
	vim.bo[buf].filetype = filetype or "markdown"
	vim.bo[buf].bufhidden = "wipe"
	vim.bo[buf].swapfile = false
	return buf
end
-- Helper: Open a vertical split and focus it
function M.open_split(buf)
	vim.cmd("vsplit")
	vim.api.nvim_win_set_buf(0, buf)
	if config.options.ui.wrap then
		vim.wo[0].wrap = true
	end
end
-- Setup the Diff View (Reference vs Generated)
function M.setup_diff_view(original_buf, generated_buf)
	-- Find windows for both buffers
	local gen_win = vim.fn.bufwinid(generated_buf)
	local orig_win = vim.fn.bufwinid(original_buf)
	if gen_win ~= -1 then
		vim.api.nvim_win_call(gen_win, function()
			vim.cmd("diffthis")
		end)
	end
	if orig_win ~= -1 then
		vim.api.nvim_win_call(orig_win, function()
			vim.cmd("diffthis")
		end)
		M.set_review_keymaps(original_buf, orig_win, generated_buf)
	end
end
-- Keymaps for Accepting/Declining Code
function M.set_review_keymaps(buf, win, scratch_buf)
	local opts = { noremap = true, silent = true, buffer = buf }
	local keys = config.options.keymaps
	-- Accept (Normal Mode)
	vim.keymap.set("n", keys.accept, function()
		vim.cmd("normal! do") -- Diff Obtain
		vim.cmd("update")
		vim.lsp.buf.format()
		print("‚úÖ Code Accepted.")
	end, opts)
	-- Accept (Visual Mode)
	vim.keymap.set("v", keys.accept, function()
		vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<Esc>", true, false, true), "x", false)
		vim.schedule(function()
			vim.cmd("'<,'>diffget")
			vim.cmd("update")
			vim.lsp.buf.format()
			print("‚úÖ Selection Accepted.")
		end)
	end, opts)
	-- Decline
	vim.keymap.set({ "n", "v" }, keys.decline, function()
		vim.cmd("diffoff")
		if vim.api.nvim_buf_is_valid(scratch_buf) then
			vim.api.nvim_buf_delete(scratch_buf, { force = true })
		end
		print("‚ùå Review Cancelled.")
	end, opts)
end
return M
```

## File: plugin/codepicker.lua
```lua
if vim.g.loaded_codepicker then
	return
end
vim.g.loaded_codepicker = true
local codepicker = require("codepicker")
local config = require("codepicker.config")
config.setup()
vim.api.nvim_create_user_command("CodePickerAsk", function(opts)
	codepicker.ask(opts.args)
end, { nargs = "+" })
vim.api.nvim_create_user_command("CodePickerEdit", function(opts)
	codepicker.refactor(opts.args)
end, { nargs = "+" })
```

